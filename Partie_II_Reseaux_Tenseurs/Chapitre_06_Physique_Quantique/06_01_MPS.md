# 6.1 √âtats Produits Matriciels (MPS)

---

## Introduction

Les **Matrix Product States** (MPS), aussi appel√©s **Tensor Trains** en math√©matiques appliqu√©es, sont la repr√©sentation la plus simple et efficace des √©tats quantiques pour les syst√®mes unidimensionnels. Ils √©vitent la croissance exponentielle du nombre de param√®tres avec la taille du syst√®me.

---

## D√©finition Math√©matique

### Forme G√©n√©rale

Un MPS repr√©sente un √©tat quantique de $n$ particules comme :

$$|\psi\rangle = \sum_{i_1, \ldots, i_n} \text{Tr}\left(A^{[1]}_{i_1} A^{[2]}_{i_2} \cdots A^{[n]}_{i_n}\right) |i_1 i_2 \cdots i_n\rangle$$

o√π :
- $|i_k\rangle$ : √©tat local de la particule $k$ (base locale)
- $A^{[k]}_{i_k}$ : matrices de taille $(\chi_{k-1}, \chi_k)$
- $\chi_k$ : **dimension de liaison** (bond dimension)
- $\text{Tr}$ : trace (pour syst√®mes p√©riodiques) ou produit simple (pour syst√®mes ouverts)

### Forme Canonique

Pour les syst√®mes ouverts (non-p√©riodiques), le MPS est souvent √©crit sous forme canonique :

$$|\psi\rangle = \sum_{i_1, \ldots, i_n} A^{[1]}_{i_1} A^{[2]}_{i_2} \cdots A^{[n]}_{i_n} |i_1 i_2 \cdots i_n\rangle$$

o√π :
- $A^{[1]}_{i_1}$ : vecteur ligne (1 √ó œá‚ÇÅ)
- $A^{[n]}_{i_n}$ : vecteur colonne (œá‚Çô‚Çã‚ÇÅ √ó 1)
- $A^{[k]}_{i_k}$ : matrices (œá‚Çñ‚Çã‚ÇÅ √ó œá‚Çñ) pour 1 < k < n

---

## Impl√©mentation

```python
import numpy as np
from scipy.linalg import svd

class MPSState:
    """
    Repr√©sentation d'un √©tat quantique en format MPS
    """
    
    def __init__(self, local_dims, bond_dims, form='mixed'):
        """
        Args:
            local_dims: tuple (d‚ÇÅ, d‚ÇÇ, ..., d‚Çô) - dimensions physiques locales
            bond_dims: tuple (œá‚ÇÅ, œá‚ÇÇ, ..., œá‚Çô‚Çã‚ÇÅ) - dimensions de liaison
            form: 'left' (canonique gauche), 'right' (canonique droite), 'mixed'
        """
        self.n_sites = len(local_dims)
        self.local_dims = np.array(local_dims)
        self.bond_dims = np.array(bond_dims)
        self.form = form
        
        assert len(bond_dims) == self.n_sites - 1, \
            f"Nombre de bond_dims ({len(bond_dims)}) doit √™tre {self.n_sites - 1}"
        
        # Initialise les tenseurs
        self.tensors = []
        for i in range(self.n_sites):
            # Bond dimensions aux bords
            chi_left = 1 if i == 0 else bond_dims[i-1]
            chi_right = 1 if i == self.n_sites - 1 else bond_dims[i]
            d_i = local_dims[i]
            
            # Cr√©e le tenseur (œá_left, d_i, œá_right)
            tensor = np.random.randn(chi_left, d_i, chi_right).astype(complex)
            
            # Normalisation initiale
            tensor = tensor / np.linalg.norm(tensor)
            
            self.tensors.append(tensor)
    
    def normalize(self):
        """Normalise le MPS"""
        # Contracte pour obtenir la norme
        norm_sq = self.compute_overlap(self)
        if abs(norm_sq) > 1e-10:
            self.tensors[0] = self.tensors[0] / np.sqrt(norm_sq)
        return self
    
    def compute_overlap(self, other):
        """
        Calcule le produit scalaire ‚ü®self|other‚ü©
        """
        # Contracte les deux MPS
        # Part du premier site
        overlap = np.tensordot(
            np.conj(self.tensors[0]), 
            other.tensors[0], 
            axes=([0, 1], [0, 1])
        )  # R√©sultat: (œá‚ÇÅ_self, œá‚ÇÅ_other)
        
        # Contracte site par site
        for i in range(1, self.n_sites):
            # Contracte avec le tenseur suivant
            overlap = np.tensordot(
                overlap,
                np.conj(self.tensors[i]),
                axes=([0], [0])
            )  # (œá_i_other, d_i, œá_{i+1}_self, œá_{i+1}_other)
            
            overlap = np.tensordot(
                overlap,
                other.tensors[i],
                axes=([1, 2], [1, 0])
            )  # (œá_{i+1}_self, œá_{i+1}_other)
        
        # Final squeeze
        return overlap.item()
    
    def compute_norm(self):
        """Calcule |||œà‚ü©||¬≤"""
        return abs(self.compute_overlap(self))
    
    def count_parameters(self):
        """Nombre total de param√®tres"""
        return sum(t.size for t in self.tensors)
    
    def full_state_size(self):
        """Taille de l'√©tat complet non compress√©"""
        return np.prod(self.local_dims)
    
    def compression_ratio(self):
        """Ratio de compression"""
        return self.full_state_size() / self.count_parameters()

# Exemple: 10 spins 1/2
mps = MPSState(
    local_dims=[2] * 10,
    bond_dims=[4] * 9
)

print("MPS pour 10 spins 1/2:")
print(f"  Sites: {mps.n_sites}")
print(f"  Dimensions locales: {mps.local_dims}")
print(f"  Dimensions de liaison: {mps.bond_dims}")
print(f"  Param√®tres: {mps.count_parameters():,}")
print(f"  √âtat complet: {mps.full_state_size():,} (2^10)")
print(f"  Compression: {mps.compression_ratio():.1f}x")
print(f"  Norme: {mps.compute_norm():.4f}")
```

---

## Forme Canonique

### Canonique Gauche (Left-Canonical)

Dans la forme canonique gauche, tous les tenseurs sauf le dernier satisfont :

$$\sum_{i_k} A^{[k]\dagger}_{i_k} A^{[k]}_{i_k} = I$$

```python
def left_canonical_form(mps):
    """
    Met le MPS sous forme canonique gauche
    """
    for k in range(mps.n_sites - 1):
        tensor = mps.tensors[k]  # (œá_{k-1}, d_k, œá_k)
        
        # Reshape en matrice: (œá_{k-1} √ó d_k, œá_k)
        matrix = tensor.reshape(-1, tensor.shape[2])
        
        # QR d√©composition
        Q, R = np.linalg.qr(matrix)
        
        # Q devient le nouveau tenseur
        mps.tensors[k] = Q.reshape(tensor.shape[0], tensor.shape[1], Q.shape[1])
        
        # R est absorb√© dans le tenseur suivant
        mps.tensors[k+1] = np.tensordot(
            R,
            mps.tensors[k+1],
            axes=([1], [0])
        )
    
    mps.form = 'left'
    return mps

# Test
mps_canonical = MPSState([2] * 5, [4] * 4)
mps_canonical = left_canonical_form(mps_canonical)
print(f"MPS en forme canonique gauche")
```

### Canonique Droite (Right-Canonical)

```python
def right_canonical_form(mps):
    """
    Met le MPS sous forme canonique droite
    """
    for k in range(mps.n_sites - 1, 0, -1):
        tensor = mps.tensors[k]  # (œá_{k-1}, d_k, œá_k)
        
        # Reshape: (œá_{k-1}, d_k √ó œá_k)
        matrix = tensor.reshape(tensor.shape[0], -1)
        
        # LQ d√©composition (QR de la transpos√©e)
        Q, R = np.linalg.qr(matrix.T)
        Q = Q.T
        R = R.T
        
        # R devient le nouveau tenseur
        mps.tensors[k] = R.reshape(R.shape[0], tensor.shape[1], tensor.shape[2])
        
        # Q est absorb√© dans le tenseur pr√©c√©dent
        mps.tensors[k-1] = np.tensordot(
            mps.tensors[k-1],
            Q,
            axes=([2], [0])
        )
    
    mps.form = 'right'
    return mps
```

### Forme Mixte

```python
def mixed_canonical_form(mps, orthogonality_center):
    """
    Forme mixte: canonique gauche jusqu'au site 'orthogonality_center',
                 canonique droite apr√®s
    
    Utile pour calculer les valeurs d'esp√©rance
    """
    # Canonique gauche jusqu'au centre
    for k in range(orthogonality_center):
        tensor = mps.tensors[k]
        matrix = tensor.reshape(-1, tensor.shape[2])
        Q, R = np.linalg.qr(matrix)
        mps.tensors[k] = Q.reshape(tensor.shape[0], tensor.shape[1], Q.shape[1])
        mps.tensors[k+1] = np.tensordot(R, mps.tensors[k+1], axes=([1], [0]))
    
    # Canonique droite apr√®s le centre
    for k in range(mps.n_sites - 1, orthogonality_center, -1):
        tensor = mps.tensors[k]
        matrix = tensor.reshape(tensor.shape[0], -1)
        Q, R = np.linalg.qr(matrix.T)
        mps.tensors[k] = R.T.reshape(R.shape[0], tensor.shape[1], tensor.shape[2])
        mps.tensors[k-1] = np.tensordot(mps.tensors[k-1], Q.T, axes=([2], [0]))
    
    mps.form = 'mixed'
    return mps
```

---

## Op√©rations sur MPS

### Application d'un Op√©rateur Local

```python
def apply_local_operator(mps, operator, site):
    """
    Applique un op√©rateur local O au site 'site'
    
    |œà'‚ü© = O^(site) |œà‚ü©
    
    Args:
        operator: matrice (d, d) agissant sur l'espace local
    """
    tensor = mps.tensors[site]  # (œá_{k-1}, d_k, œá_k)
    
    # Contracte l'op√©rateur: O_{i,j} A^{[k]}_{j}
    # (œá_{k-1}, d_k, œá_k) contract√© avec (d_k, d_k) sur l'indice physique
    new_tensor = np.tensordot(tensor, operator, axes=([1], [1]))
    # R√©sultat: (œá_{k-1}, œá_k, d_k) - r√©organise
    new_tensor = np.moveaxis(new_tensor, -1, 1)
    
    mps.tensors[site] = new_tensor
    
    return mps

# Exemple: application de Pauli-Z
pauli_z = np.array([[1, 0], [0, -1]], dtype=complex)
mps_test = MPSState([2] * 5, [4] * 4)
apply_local_operator(mps_test, pauli_z, site=2)
```

### Application d'un Op√©rateur √† Deux Sites

```python
def apply_two_site_operator(mps, operator, sites, max_bond_dim=None, truncation_error=1e-10):
    """
    Applique un op√©rateur √† deux sites adjacents
    
    L'op√©rateur est de la forme O^{ij}_{i'j'} et agit sur les sites (i, j)
    
    Apr√®s application, le MPS doit √™tre renormalis√© (SVD)
    
    Args:
        operator: tenseur (d_i, d_j, d_i', d_j')
        sites: (i, j) indices des sites (adjacents)
        max_bond_dim: dimension de liaison maximale (None = pas de limite)
        truncation_error: seuil d'erreur de troncature
    """
    i, j = sites
    assert abs(i - j) == 1, "Sites doivent √™tre adjacents"
    
    if i > j:
        i, j = j, i  # Assure i < j
    
    # Fusionne temporairement les deux tenseurs
    left_tensor = mps.tensors[i]   # (œá_{i-1}, d_i, œá_i)
    right_tensor = mps.tensors[j]  # (œá_{j-1}, d_j, œá_j) o√π j-1 = i
    
    # Fusionne: contracte sur œá_i
    merged = np.tensordot(left_tensor, right_tensor, axes=([2], [0]))
    # Shape: (œá_{i-1}, d_i, d_j, œá_j)
    
    # Applique l'op√©rateur
    # Reshape pour avoir (œá_{i-1}, d_i√ód_j, œá_j)
    merged = merged.reshape(merged.shape[0], -1, merged.shape[3])
    
    # Contracte avec l'op√©rateur
    # operator: (d_i, d_j, d_i', d_j')
    # Reshape operator: (d_i√ód_j, d_i'√ód_j')
    operator_matrix = operator.reshape(
        operator.shape[0] * operator.shape[1],
        operator.shape[2] * operator.shape[3]
    )
    
    # Applique: merged @ operator_matrix
    new_merged = np.tensordot(merged, operator_matrix, axes=([1], [0]))
    # Shape: (œá_{i-1}, d_i'√ód_j', œá_j)
    
    # SVD pour d√©composer en deux tenseurs
    # Reshape: (œá_{i-1} √ó d_i', d_j' √ó œá_j)
    matrix = new_merged.reshape(-1, new_merged.shape[1] * new_merged.shape[2])
    
    U, S, Vt = svd(matrix, full_matrices=False)
    
    # Troncature
    if max_bond_dim is not None:
        U = U[:, :max_bond_dim]
        S = S[:max_bond_dim]
        Vt = Vt[:max_bond_dim, :]
    
    # Reconstruction
    left_new = U.reshape(mps.tensors[i].shape[0], operator.shape[2], U.shape[1])
    right_new = (np.diag(S) @ Vt).reshape(Vt.shape[0], operator.shape[3], mps.tensors[j].shape[2])
    
    mps.tensors[i] = left_new
    mps.tensors[j] = right_new
    
    # Ajuste les bond_dims
    new_bond_dim = U.shape[1]
    if i > 0:
        mps.bond_dims[i-1] = new_bond_dim
    mps.bond_dims[j-1] = new_bond_dim
    
    return mps, np.sum(S[max_bond_dim:]**2) if max_bond_dim else 0.0

# Exemple: op√©rateur d'√©change (SWAP)
def create_swap_operator(dim):
    """Cr√©e l'op√©rateur SWAP pour deux qubits"""
    swap = np.zeros((dim, dim, dim, dim), dtype=complex)
    for i in range(dim):
        for j in range(dim):
            swap[i, j, j, i] = 1.0
    return swap

swap_op = create_swap_operator(2)
mps_test = MPSState([2] * 5, [4] * 4)
apply_two_site_operator(mps_test, swap_op, sites=(1, 2), max_bond_dim=8)
```

---

## Compression d'un √âtat Quantique

### Conversion d'un √âtat Complet en MPS

```python
def state_to_mps(state, local_dims, max_bond_dim=None, tolerance=1e-10):
    """
    Convertit un √©tat quantique complet en format MPS via SVD
    
    Args:
        state: vecteur de l'√©tat complet (shape = (d‚ÇÅ √ó d‚ÇÇ √ó ... √ó d‚Çô,))
        local_dims: tuple (d‚ÇÅ, d‚ÇÇ, ..., d‚Çô)
        max_bond_dim: dimension de liaison maximale
        tolerance: seuil pour la troncature SVD
    """
    assert len(state) == np.prod(local_dims), \
        f"Taille de l'√©tat ({len(state)}) doit √©galer ‚àèd_i ({np.prod(local_dims)})"
    
    state = state.reshape(*local_dims)
    n_sites = len(local_dims)
    
    mps_tensors = []
    bond_dims = []
    remainder = state
    
    for k in range(n_sites - 1):
        # Reshape pour SVD: (d‚ÇÅ√ó...√ód‚Çñ, d_{k+1}√ó...√ód‚Çô)
        left_size = np.prod(local_dims[:k+1])
        right_size = np.prod(local_dims[k+1:])
        
        remainder = remainder.reshape(left_size, right_size)
        
        # SVD
        U, S, Vt = svd(remainder, full_matrices=False)
        
        # Troncature
        if tolerance is not None:
            # Garde les valeurs singuli√®res > tolerance * S[0]
            keep = np.sum(S > tolerance * S[0])
            if max_bond_dim is not None:
                keep = min(keep, max_bond_dim)
        elif max_bond_dim is not None:
            keep = min(len(S), max_bond_dim)
        else:
            keep = len(S)
        
        U = U[:, :keep]
        S = S[:keep]
        Vt = Vt[:keep, :]
        
        # Forme le tenseur MPS
        # U: (left_size, œá_k) = (d‚ÇÅ√ó...√ód‚Çñ, œá_k)
        # Doit √™tre reshap√© en (d‚ÇÅ, d‚ÇÇ, ..., d‚Çñ, œá_k)
        if k == 0:
            # Premier tenseur: (d‚ÇÅ, œá‚ÇÅ)
            tensor = U.reshape(local_dims[0], keep)
            tensor = tensor[:, :, np.newaxis]  # (d‚ÇÅ, œá‚ÇÅ, 1)
        else:
            # Tenseur pr√©c√©dent: (œá_{k-1}, d_k)
            prev_shape = mps_tensors[-1].shape
            U = U.reshape(prev_shape[2], local_dims[k], keep)
            mps_tensors[-1] = np.concatenate([mps_tensors[-1][:, :, :, np.newaxis], U[:, :, :, np.newaxis]], axis=-1).squeeze()
            tensor = U  # (œá_{k-1}, d_k, œá_k)
        
        mps_tensors.append(tensor)
        bond_dims.append(keep)
        
        # Pr√©pare pour l'it√©ration suivante
        remainder = np.diag(S) @ Vt
    
    # Dernier tenseur
    remainder = remainder.reshape(-1, local_dims[-1])
    mps_tensors.append(remainder.T[:, :, np.newaxis])  # (œá_{n-1}, d‚Çô, 1)
    
    return mps_tensors, bond_dims

# Test sur un petit √©tat
small_state = np.random.randn(2**4).astype(complex)
small_state = small_state / np.linalg.norm(small_state)

tensors, bond_dims = state_to_mps(small_state, local_dims=[2]*4, max_bond_dim=4)
print(f"√âtat 4 qubits compress√©:")
print(f"  Bond dims: {bond_dims}")
print(f"  Param√®tres: {sum(t.size for t in tensors)}")
print(f"  vs √©tat complet: {2**4}")
```

---

## Exercices

### Exercice 6.1.1
Impl√©mentez une fonction qui calcule la valeur d'esp√©rance d'un op√©rateur local sur un MPS.

### Exercice 6.1.2
Cr√©ez un MPS repr√©sentant un √©tat produit (sans intrication) et v√©rifiez que les bond_dims sont tous 1.

### Exercice 6.1.3
Impl√©mentez l'algorithme DMRG (Density Matrix Renormalization Group) simplifi√© utilisant MPS.

---

## Points Cl√©s √† Retenir

> üìå **MPS repr√©sente un √©tat quantique avec O(n √ó d √ó œá¬≤) param√®tres au lieu de O(d‚Åø)**

> üìå **La forme canonique simplifie les calculs de valeurs d'esp√©rance**

> üìå **Les op√©rateurs √† deux sites n√©cessitent une renormalisation (SVD)**

> üìå **La compression MPS permet de repr√©senter efficacement les √©tats peu intric√©s**

---

*Section suivante : [6.2 √âtats Projet√©s par Paires Entrelac√©es (PEPS)](./06_02_PEPS.md)*

