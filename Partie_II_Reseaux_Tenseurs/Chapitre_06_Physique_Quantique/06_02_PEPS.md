# 6.2 Ã‰tats ProjetÃ©s par Paires EntrelacÃ©es (PEPS)

---

## Introduction

Les **Projected Entangled Pair States** (PEPS) gÃ©nÃ©ralisent les MPS aux systÃ¨mes bidimensionnels (2D) et multidimensionnels. Chaque site est connectÃ© Ã  plusieurs voisins, ce qui permet de capturer l'intrication dans toutes les directions spatiales.

---

## Motivation : Limitation des MPS en 2D

### ProblÃ¨me avec MPS en 2D

Les MPS sont optimaux pour les systÃ¨mes 1D mais ont des limitations en 2D :
- L'intrication 2D nÃ©cessite des bond_dims croissant exponentiellement avec la taille
- Les systÃ¨mes 2D critiques ont une intrication de surface (area law scaling)

### Solution : PEPS

Les PEPS rÃ©solvent ce problÃ¨me en permettant des connexions dans toutes les directions :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Structure PEPS 2D                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”                                      â”‚
â”‚        â”‚  â—‹â”€â”€â”¼â”€â”€â—‹â”€â”€â”¼â”€â”€â—‹  â”‚                                      â”‚
â”‚        â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚                                      â”‚
â”‚        â”œâ”€â”€â—‹â”€â”€â”¼â”€â”€â—‹â”€â”€â”¼â”€â”€â—‹â”€â”€â”¤                                      â”‚
â”‚        â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚                                      â”‚
â”‚        â”œâ”€â”€â—‹â”€â”€â”¼â”€â”€â—‹â”€â”€â”¼â”€â”€â—‹â”€â”€â”¤                                      â”‚
â”‚        â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚                                      â”‚
â”‚        â””â”€â”€â—‹â”€â”€â”´â”€â”€â—‹â”€â”€â”´â”€â”€â—‹â”€â”€â”˜                                      â”‚
â”‚                                                                 â”‚
â”‚  Chaque â—‹ est un tenseur 5D: (bond_up, bond_down,              â”‚
â”‚                                bond_left, bond_right, physical) â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## DÃ©finition MathÃ©matique

### PEPS 2D

Un PEPS 2D sur un rÃ©seau $L_x \times L_y$ reprÃ©sente un Ã©tat comme :

$$|\psi\rangle = \sum_{\{i_{x,y}\}} \left(\prod_{(x,y)} A^{[x,y]}_{i_{x,y}}\right) |\{i_{x,y}\}\rangle$$

oÃ¹ chaque $A^{[x,y]}$ est un tenseur avec :
- 4 indices de liaison (haut, bas, gauche, droite)
- 1 indice physique (Ã©tat local)

### Structure du Tenseur

Pour un site $(x, y)$, le tenseur a la forme :
- $A^{[x,y]} \in \mathbb{C}^{\chi \times \chi \times \chi \times \chi \times d}$
- OÃ¹ $\chi$ est la dimension de liaison
- Et $d$ est la dimension physique locale

---

## ImplÃ©mentation

```python
import numpy as np

class PEPSState:
    """
    ReprÃ©sentation d'un Ã©tat quantique en format PEPS 2D
    """
    
    def __init__(self, lattice_shape, physical_dim, bond_dim):
        """
        Args:
            lattice_shape: tuple (Lx, Ly) - dimensions du rÃ©seau
            physical_dim: d - dimension de l'espace physique local
            bond_dim: Ï‡ - dimension de liaison (identique pour toutes les directions)
        """
        self.Lx, self.Ly = lattice_shape
        self.physical_dim = physical_dim
        self.bond_dim = bond_dim
        
        # Dictionnaire: (x, y) -> tenseur
        self.tensors = {}
        
        # Initialise les tenseurs
        for x in range(self.Lx):
            for y in range(self.Ly):
                # Dimensions des liens aux bords = 1
                bond_up = 1 if y == 0 else bond_dim
                bond_down = 1 if y == self.Ly - 1 else bond_dim
                bond_left = 1 if x == 0 else bond_dim
                bond_right = 1 if x == self.Lx - 1 else bond_dim
                
                # Tenseur (bond_up, bond_down, bond_left, bond_right, physical)
                tensor = np.random.randn(
                    bond_up, bond_down, bond_left, bond_right, physical_dim
                ).astype(complex)
                
                # Normalisation
                tensor = tensor / np.linalg.norm(tensor)
                
                self.tensors[(x, y)] = tensor
    
    def count_parameters(self):
        """Nombre total de paramÃ¨tres"""
        return sum(t.size for t in self.tensors.values())
    
    def full_state_size(self):
        """Taille de l'Ã©tat complet"""
        return self.physical_dim ** (self.Lx * self.Ly)
    
    def compression_ratio(self):
        """Ratio de compression"""
        return self.full_state_size() / self.count_parameters()
    
    def get_tensor(self, x, y):
        """RÃ©cupÃ¨re le tenseur au site (x, y)"""
        return self.tensors[(x, y)]

# Exemple: rÃ©seau 4Ã—4
peps = PEPSState(lattice_shape=(4, 4), physical_dim=2, bond_dim=3)

print("PEPS 2D:")
print(f"  RÃ©seau: {peps.Lx}Ã—{peps.Ly}")
print(f"  Dimension physique: {peps.physical_dim}")
print(f"  Dimension de liaison: {peps.bond_dim}")
print(f"  ParamÃ¨tres: {peps.count_parameters():,}")
print(f"  Ã‰tat complet: {peps.full_state_size():,}")
print(f"  Compression: {peps.compression_ratio():.2e}x")
```

---

## Contraction de PEPS

### ProblÃ¨me de la Contraction Exacte

Contracter un PEPS 2D est **NP-hard** en gÃ©nÃ©ral. La complexitÃ© croÃ®t exponentiellement avec la taille du rÃ©seau.

### StratÃ©gies de Contraction

#### 1. Contraction SÃ©quentielle (CoÃ»teux)

```python
def contract_peps_sequential(peps):
    """
    Contraction naÃ¯ve (trÃ¨s coÃ»teuse!)
    
    Contracte ligne par ligne, puis colonne par colonne
    """
    # Cette mÃ©thode est trÃ¨s inefficace mais illustre le principe
    result = None
    
    # Contracte ligne par ligne
    for y in range(peps.Ly):
        row_tensor = None
        
        for x in range(peps.Lx):
            tensor = peps.get_tensor(x, y)
            
            if row_tensor is None:
                row_tensor = tensor
            else:
                # Contracte horizontalement
                row_tensor = np.tensordot(
                    row_tensor, tensor, 
                    axes=([3], [2])  # contracte bond_right de gauche avec bond_left de droite
                )
        
        # Contracte verticalement avec les lignes prÃ©cÃ©dentes
        if result is None:
            result = row_tensor
        else:
            # Contracte bond_down de result avec bond_up de row_tensor
            result = np.tensordot(
                result, row_tensor,
                axes=([1], [0])  # contracte bond_down avec bond_up
            )
    
    # Squeeze les dimensions restantes
    return result.squeeze()

# âš ï¸ ATTENTION: TrÃ¨s coÃ»teux pour des rÃ©seaux > 3Ã—3!
# peps_small = PEPSState((3, 3), 2, 2)
# result = contract_peps_sequential(peps_small)
```

#### 2. Contraction Approximative (CTMRG)

```python
class CTMRG:
    """
    Corner Transfer Matrix Renormalization Group
    
    MÃ©thode approximative pour contracter des PEPS
    """
    
    def __init__(self, peps, chi_env=None):
        """
        Args:
            peps: PEPSState Ã  contracter
            chi_env: dimension de liaison pour l'environnement
        """
        self.peps = peps
        self.chi_env = chi_env if chi_env else peps.bond_dim
        
        # Environnement: matrices de coin et matrices de bord
        self.corners = {}  # (x, y) -> corner matrix
        self.edges_h = {}  # horizontal edges
        self.edges_v = {}  # vertical edges
        
        # Initialise l'environnement (approximation triviale)
        self._initialize_environment()
    
    def _initialize_environment(self):
        """Initialise l'environnement avec des matrices identitÃ©"""
        # SimplifiÃ©
        pass
    
    def update_environment(self, num_iterations=10):
        """
        Met Ã  jour l'environnement par itÃ©ration
        
        L'algorithme CTMRG itÃ¨re jusqu'Ã  convergence
        """
        for iteration in range(num_iterations):
            # Pour chaque site, met Ã  jour l'environnement
            # (SimplifiÃ© - implÃ©mentation complÃ¨te est complexe)
            pass
    
    def compute_expectation_value(self, operator, site):
        """
        Calcule âŸ¨Ïˆ|O|ÏˆâŸ© pour un opÃ©rateur local
        
        Utilise l'environnement pour Ã©viter la contraction complÃ¨te
        """
        x, y = site
        tensor = self.peps.get_tensor(x, y)
        
        # Contracte l'opÃ©rateur avec le tenseur
        # (SimplifiÃ©)
        return 0.0
```

#### 3. Contraction par Arbre (Tree Network)

```python
def contract_peps_tree(peps, tree_structure):
    """
    Contracte le PEPS selon une structure arborescente
    
    RÃ©duit la complexitÃ© mais nÃ©cessite une bonne structure
    """
    # L'idÃ©e: regrouper les sites en arbre binaire
    # Contracte de bas en haut de l'arbre
    pass
```

---

## PEPS 3D et Dimensions SupÃ©rieures

### PEPS 3D

```python
class PEPS3D:
    """
    PEPS pour systÃ¨mes 3D
    """
    
    def __init__(self, lattice_shape, physical_dim, bond_dim):
        """
        Args:
            lattice_shape: (Lx, Ly, Lz)
            physical_dim: d
            bond_dim: Ï‡
        """
        self.Lx, self.Ly, self.Lz = lattice_shape
        self.physical_dim = physical_dim
        self.bond_dim = bond_dim
        
        self.tensors = {}
        
        for x in range(self.Lx):
            for y in range(self.Ly):
                for z in range(self.Lz):
                    # 6 directions de liaison en 3D
                    bond_x_minus = 1 if x == 0 else bond_dim
                    bond_x_plus = 1 if x == self.Lx - 1 else bond_dim
                    bond_y_minus = 1 if y == 0 else bond_dim
                    bond_y_plus = 1 if y == self.Ly - 1 else bond_dim
                    bond_z_minus = 1 if z == 0 else bond_dim
                    bond_z_plus = 1 if z == self.Lz - 1 else bond_dim
                    
                    # Tenseur 7D: (6 bonds + 1 physical)
                    tensor = np.random.randn(
                        bond_x_minus, bond_x_plus,
                        bond_y_minus, bond_y_plus,
                        bond_z_minus, bond_z_plus,
                        physical_dim
                    ).astype(complex)
                    
                    self.tensors[(x, y, z)] = tensor
    
    def count_parameters(self):
        return sum(t.size for t in self.tensors.values())
    
    def full_state_size(self):
        return self.physical_dim ** (self.Lx * self.Ly * self.Lz)

# Exemple 3D
peps_3d = PEPS3D(lattice_shape=(3, 3, 3), physical_dim=2, bond_dim=2)
print(f"PEPS 3D: {peps_3d.count_parameters():,} paramÃ¨tres")
print(f"Ã‰tat complet: {peps_3d.full_state_size():,}")
```

---

## Normalisation et Canonique Form

### ProblÃ¨me de la Normalisation

Normaliser un PEPS est difficile car il faut calculer âŸ¨Ïˆ|ÏˆâŸ©, ce qui nÃ©cessite une contraction complÃ¨te (coÃ»teuse).

### Approximations

```python
def approximate_peps_norm(peps, max_iterations=20):
    """
    Approxime la norme d'un PEPS sans contraction complÃ¨te
    
    Utilise des mÃ©thodes variationnelles ou CTMRG
    """
    # MÃ©thode simplifiÃ©e: utilise l'environnement CTMRG
    ctmrg = CTMRG(peps)
    ctmrg.update_environment(max_iterations)
    
    # Calcule âŸ¨Ïˆ|ÏˆâŸ© approximativement via l'environnement
    # (SimplifiÃ©)
    return 1.0
```

---

## Applications

### SystÃ¨mes FrustrÃ©s

Les PEPS sont particuliÃ¨rement utiles pour les systÃ¨mes avec frustration (spin glass, systÃ¨mes dÃ©sordonnÃ©s).

### PropriÃ©tÃ©s Topologiques

Les PEPS peuvent reprÃ©senter des Ã©tats topologiques avec des phases topologiques.

### Calcul Variationnel

```python
class VariationalPEPS:
    """
    Utilise PEPS pour minimiser l'Ã©nergie d'un hamiltonien
    """
    
    def __init__(self, hamiltonian, lattice_shape, physical_dim, bond_dim):
        self.hamiltonian = hamiltonian
        self.peps = PEPSState(lattice_shape, physical_dim, bond_dim)
    
    def compute_energy(self):
        """
        Calcule âŸ¨Ïˆ|H|ÏˆâŸ© / âŸ¨Ïˆ|ÏˆâŸ©
        
        NÃ©cessite la contraction de PEPS (approximative)
        """
        # Pour chaque terme du hamiltonien:
        # - Contracte le PEPS avec le terme
        # - Utilise l'environnement pour Ã©viter la contraction complÃ¨te
        pass
    
    def optimize(self, num_iterations=100):
        """
        Optimise les tenseurs pour minimiser l'Ã©nergie
        """
        for iteration in range(num_iterations):
            # Pour chaque site:
            # 1. Calcule l'environnement
            # 2. RÃ©sout le problÃ¨me d'optimisation local
            # 3. Met Ã  jour le tenseur
            pass
```

---

## Comparaison MPS vs PEPS

```python
def compare_mps_peps():
    """
    Compare MPS et PEPS pour un systÃ¨me 2D
    """
    Lx, Ly = 4, 4
    n_sites = Lx * Ly
    d = 2  # qubits
    chi = 4  # bond dimension
    
    # MPS (1D mapping du rÃ©seau 2D)
    mps_params = n_sites * d * chi * chi  # Approximation
    
    # PEPS
    peps = PEPSState((Lx, Ly), d, chi)
    peps_params = peps.count_parameters()
    
    full_size = 2 ** (Lx * Ly)
    
    print("Comparaison MPS vs PEPS (rÃ©seau 4Ã—4):")
    print(f"  Ã‰tat complet: {full_size:,}")
    print(f"  MPS (mapping 1D): ~{mps_params:,} paramÃ¨tres")
    print(f"  PEPS: {peps_params:,} paramÃ¨tres")
    print(f"  Compression MPS: {full_size / mps_params:.1e}x")
    print(f"  Compression PEPS: {full_size / peps_params:.1e}x")

compare_mps_peps()
```

---

## Exercices

### Exercice 6.2.1
ImplÃ©mentez une fonction qui contracte un petit PEPS 2Ã—2 exactement et comparez avec l'Ã©tat complet.

### Exercice 6.2.2
CrÃ©ez un PEPS reprÃ©sentant un Ã©tat produit (sans intrication) et vÃ©rifiez que la contraction donne la norme attendue.

### Exercice 6.2.3
ImplÃ©mentez une version simplifiÃ©e de CTMRG pour contracter approximativement un PEPS.

---

## Points ClÃ©s Ã  Retenir

> ğŸ“Œ **PEPS gÃ©nÃ©ralise MPS aux dimensions supÃ©rieures (2D, 3D)**

> ğŸ“Œ **La contraction exacte de PEPS est NP-hard, nÃ©cessite des approximations**

> ğŸ“Œ **CTMRG est la mÃ©thode standard pour contracter des PEPS approximativement**

> ğŸ“Œ **PEPS capture mieux l'intrication 2D que MPS avec un mapping 1D**

> ğŸ“Œ **La complexitÃ© de contraction croÃ®t exponentiellement avec la dimension du rÃ©seau**

---

*Section suivante : [6.3 MERA (Multi-scale Entanglement Renormalization Ansatz)](./06_03_MERA.md)*

