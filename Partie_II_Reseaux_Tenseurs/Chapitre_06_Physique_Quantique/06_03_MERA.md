# 6.3 MERA (Multi-scale Entanglement Renormalization Ansatz)

---

## Introduction

Le **Multi-scale Entanglement Renormalization Ansatz** (MERA) est une reprÃ©sentation hiÃ©rarchique des Ã©tats quantiques qui capture l'intrication Ã  toutes les Ã©chelles. Il combine des opÃ©rations de **disentanglement** et de **renormalisation** pour reprÃ©senter efficacement les systÃ¨mes critiques.

---

## Motivation : Intrication Multi-Ã©chelle

### ProblÃ¨me avec MPS/PEPS

Les MPS et PEPS sont excellents pour les Ã©tats avec intrication locale, mais :
- Les systÃ¨mes critiques ont de l'intrication Ã  toutes les Ã©chelles
- L'intrication longue distance nÃ©cessite des bond_dims Ã©levÃ©s

### Solution : Structure HiÃ©rarchique

MERA utilise une structure arborescente avec :
- **Disentanglers** : Ã©liminent l'intrication locale
- **Isometries** : projettent vers des Ã©chelles plus grandes
- **Structure multi-Ã©chelle** : capture l'intrication Ã  toutes les distances

---

## Structure MERA

### Diagramme

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Structure MERA (1D)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Layer 2:        â”Œâ”€â”€â”€â”¬â”€â”€â”€â”                                     â”‚
â”‚                  â”‚ U â”‚ U â”‚  (Disentanglers)                    â”‚
â”‚                â”Œâ”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”                                   â”‚
â”‚  Layer 1:      â”‚ V â”‚   â”‚ V â”‚  (Isometries)                     â”‚
â”‚              â”Œâ”€â”´â”€â”€â”€â”´â”€â” â”Œâ”€â”´â”€â”€â”€â”´â”€â”                              â”‚
â”‚  Physical:   â”‚   |   â”‚ â”‚   |   â”‚  (Sites physiques)            â”‚
â”‚              0   1   2   3   4   5                              â”‚
â”‚                                                                 â”‚
â”‚  U = Disentangler (unitaire)                                    â”‚
â”‚  V = Isometry (projection)                                      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## DÃ©finition MathÃ©matique

### Composants

1. **Disentangler** $U$ : Matrice unitaire qui Ã©limine l'intrication entre deux sites
   - $U^\dagger U = I$

2. **Isometry** $V$ : Projection vers une Ã©chelle supÃ©rieure
   - $V^\dagger V = I$ (mais $V V^\dagger \neq I$ en gÃ©nÃ©ral)

### Construction HiÃ©rarchique

L'Ã©tat MERA est construit par :
1. Application des disentanglers
2. Application des isometries
3. RÃ©pÃ©tition aux Ã©chelles supÃ©rieures

---

## ImplÃ©mentation

```python
import numpy as np

class MERAState:
    """
    ReprÃ©sente un Ã©tat quantique en format MERA
    """
    
    def __init__(self, n_sites, physical_dim, bond_dim, n_layers):
        """
        Args:
            n_sites: nombre de sites physiques (doit Ãªtre puissance de 2)
            physical_dim: dimension de l'espace physique local (d)
            bond_dim: dimension de liaison (Ï‡)
            n_layers: nombre de couches de rÃ©normalisation
        """
        assert (n_sites & (n_sites - 1)) == 0, "n_sites doit Ãªtre une puissance de 2"
        
        self.n_sites = n_sites
        self.physical_dim = physical_dim
        self.bond_dim = bond_dim
        self.n_layers = n_layers
        
        # Disentanglers et isometries par couche
        self.disentanglers = []  # List of lists
        self.isometries = []     # List of lists
        
        current_sites = n_sites
        
        for layer in range(n_layers):
            # Disentanglers: unitaires sur paires de sites
            n_pairs = current_sites // 2
            layer_disentanglers = []
            
            for _ in range(n_pairs):
                # Disentangler: unitaire (dÂ², dÂ²) pour deux sites
                U = self._random_unitary(physical_dim ** 2)
                layer_disentanglers.append(U)
            
            self.disentanglers.append(layer_disentanglers)
            
            # Isometries: projection vers couche supÃ©rieure
            layer_isometries = []
            
            for _ in range(n_pairs):
                # Isometry: (dÂ², d) - projette deux sites vers un
                V = self._random_isometry(physical_dim ** 2, physical_dim)
                layer_isometries.append(V)
            
            self.isometries.append(layer_isometries)
            
            current_sites = current_sites // 2
    
    @staticmethod
    def _random_unitary(n):
        """
        GÃ©nÃ¨re une matrice unitaire alÃ©atoire via QR
        """
        A = np.random.randn(n, n).astype(complex)
        A = A + 1j * np.random.randn(n, n)
        
        Q, R = np.linalg.qr(A)
        # Phase correction pour garantir l'unitÃ©
        D = np.diag(R) / np.abs(np.diag(R))
        Q = Q @ np.diag(D)
        
        return Q
    
    @staticmethod
    def _random_isometry(n_in, n_out):
        """
        GÃ©nÃ¨re une isomÃ©trie alÃ©atoire
        
        V: (n_in, n_out) tel que Vâ€  V = I_{n_out}
        """
        assert n_in >= n_out, "n_in doit Ãªtre >= n_out pour une isomÃ©trie"
        
        A = np.random.randn(n_in, n_out).astype(complex)
        A = A + 1j * np.random.randn(n_in, n_out)
        
        # QR et garde les n_out premiÃ¨res colonnes
        Q, _ = np.linalg.qr(A)
        
        return Q[:, :n_out]
    
    def count_parameters(self):
        """Nombre total de paramÃ¨tres"""
        params = 0
        
        for layer in range(self.n_layers):
            # Disentanglers: matrices unitaires (dÂ², dÂ²)
            for U in self.disentanglers[layer]:
                # Une matrice unitaire a dâ´ paramÃ¨tres indÃ©pendants
                params += U.shape[0] ** 2
            
            # Isometries: (dÂ², d)
            for V in self.isometries[layer]:
                params += V.shape[0] * V.shape[1]
        
        return params
    
    def full_state_size(self):
        """Taille de l'Ã©tat complet"""
        return self.physical_dim ** self.n_sites

# Exemple
mera = MERAState(n_sites=8, physical_dim=2, bond_dim=4, n_layers=3)

print("MERA:")
print(f"  Sites physiques: {mera.n_sites}")
print(f"  Dimension physique: {mera.physical_dim}")
print(f"  Nombre de couches: {mera.n_layers}")
print(f"  ParamÃ¨tres: {mera.count_parameters():,}")
print(f"  Ã‰tat complet: {mera.full_state_size():,}")
print(f"  Compression: {mera.full_state_size() / mera.count_parameters():.1f}x")
```

---

## Construction de l'Ã‰tat

### Application des Couches

```python
def apply_mera_layer(state, disentanglers, isometries):
    """
    Applique une couche MERA Ã  un Ã©tat
    
    Args:
        state: vecteur d'Ã©tat (2^n,)
        disentanglers: liste de matrices unitaires
        isometries: liste d'isomÃ©tries
    """
    n_sites = int(np.log2(len(state)))
    state = state.reshape([2] * n_sites)
    
    # 1. Applique les disentanglers
    for i, U in enumerate(disentanglers):
        # U agit sur les sites (2i, 2i+1)
        site1 = 2 * i
        site2 = 2 * i + 1
        
        # Reshape pour appliquer U
        # state: (..., d_site1, d_site2, ...)
        # U: (dÂ², dÂ²)
        
        # Contracte U avec les sites
        # (SimplifiÃ© - nÃ©cessite reshape appropriÃ©)
        pass
    
    # 2. Applique les isometries
    for i, V in enumerate(isometries):
        # V projette les sites (2i, 2i+1) vers un nouveau site
        # (SimplifiÃ©)
        pass
    
    return state.flatten()

def construct_mera_state(mera):
    """
    Construit l'Ã©tat complet depuis la structure MERA
    
    Commence par l'Ã©tat du niveau le plus haut et descend
    """
    # Ã‰tat au niveau le plus haut (1 site aprÃ¨s toutes les couches)
    top_state = np.ones(mera.physical_dim, dtype=complex)
    top_state = top_state / np.linalg.norm(top_state)
    
    # Descend couche par couche
    current_state = top_state
    
    for layer in range(mera.n_layers - 1, -1, -1):
        # Applique les isometries (expansion)
        # Applique les disentanglers
        # (DÃ©taillÃ© - nÃ©cessite une implÃ©mentation complÃ¨te)
        pass
    
    return current_state
```

---

## Applications

### SystÃ¨mes Critiques

MERA est particuliÃ¨rement adaptÃ© aux systÃ¨mes critiques (points de transition de phase) oÃ¹ l'intrication est prÃ©sente Ã  toutes les Ã©chelles.

### Calcul de CorrÃ©lations

```python
def compute_correlation_mera(mera, operator1, operator2, sites):
    """
    Calcule la corrÃ©lation âŸ¨Oâ‚(site1) Oâ‚‚(site2)âŸ©
    
    Utilise la structure hiÃ©rarchique pour calculer efficacement
    """
    i, j = sites
    
    # La structure MERA permet de calculer les corrÃ©lations
    # en suivant les chemins dans l'arbre
    # (SimplifiÃ©)
    return 0.0
```

### Optimisation Variationnelle

```python
class VariationalMERA:
    """
    Optimise un Ã©tat MERA pour minimiser l'Ã©nergie
    """
    
    def __init__(self, hamiltonian, n_sites, physical_dim, bond_dim, n_layers):
        self.hamiltonian = hamiltonian
        self.mera = MERAState(n_sites, physical_dim, bond_dim, n_layers)
    
    def compute_energy(self):
        """
        Calcule âŸ¨Ïˆ|H|ÏˆâŸ© / âŸ¨Ïˆ|ÏˆâŸ©
        
        Utilise la structure MERA pour calculer efficacement
        """
        # Pour chaque terme du hamiltonien:
        # - Trouve le chemin dans l'arbre MERA
        # - Contracte selon ce chemin
        pass
    
    def optimize_layer(self, layer_idx):
        """
        Optimise une couche spÃ©cifique
        
        Fixe les autres couches et optimise disentanglers + isometries
        """
        # Optimisation locale
        pass
    
    def optimize(self, num_iterations=100):
        """
        Optimise itÃ©rativement toutes les couches
        """
        for iteration in range(num_iterations):
            # Optimise chaque couche de bas en haut
            for layer in range(self.mera.n_layers):
                self.optimize_layer(layer)
```

---

## Variantes de MERA

### MERA 2D

```python
class MERA2D:
    """
    MERA pour systÃ¨mes 2D
    """
    
    def __init__(self, lattice_shape, physical_dim, bond_dim, n_layers):
        """
        Args:
            lattice_shape: (Lx, Ly) - doit Ãªtre puissance de 2
            physical_dim: d
            bond_dim: Ï‡
            n_layers: nombre de couches
        """
        self.Lx, self.Ly = lattice_shape
        assert (self.Lx & (self.Lx - 1)) == 0, "Lx doit Ãªtre puissance de 2"
        assert (self.Ly & (self.Ly - 1)) == 0, "Ly doit Ãªtre puissance de 2"
        
        self.physical_dim = physical_dim
        self.bond_dim = bond_dim
        self.n_layers = n_layers
        
        # Disentanglers et isometries par couche
        # En 2D, chaque couche rÃ©duit le rÃ©seau de moitiÃ© dans chaque direction
        self.disentanglers = []
        self.isometries = []
```

### Binary MERA vs Ternary MERA

- **Binary MERA** : Chaque isometry combine 2 sites â†’ 1 site
- **Ternary MERA** : Chaque isometry combine 3 sites â†’ 1 site (meilleure approximation pour certains systÃ¨mes)

---

## ComplexitÃ©

### ComplexitÃ© Computationnelle

```python
def mera_complexity(n_sites, physical_dim, bond_dim, n_layers):
    """
    Estime la complexitÃ© computationnelle de MERA
    """
    # Pour chaque couche:
    # - Disentanglers: O(dâ´) par opÃ©ration
    # - Isometries: O(dÂ³) par opÃ©ration
    # - Nombre d'opÃ©rations dÃ©croÃ®t par couche
    
    total_ops = 0
    sites = n_sites
    
    for layer in range(n_layers):
        n_ops = sites // 2
        
        # OpÃ©rations disentanglers
        disentangler_ops = n_ops * (physical_dim ** 4)
        
        # OpÃ©rations isometries
        isometry_ops = n_ops * (physical_dim ** 3)
        
        total_ops += disentangler_ops + isometry_ops
        
        sites = sites // 2
    
    return total_ops

complexity = mera_complexity(n_sites=16, physical_dim=2, bond_dim=4, n_layers=4)
print(f"ComplexitÃ© MERA (16 sites, 4 couches): ~{complexity:,} opÃ©rations")
```

---

## Comparaison avec MPS/PEPS

```python
def compare_representations():
    """
    Compare MPS, PEPS et MERA
    """
    n_sites = 16
    d = 2
    
    print("Comparaison des reprÃ©sentations (16 sites, d=2):")
    print("-" * 60)
    
    # MPS
    chi_mps = 4
    mps_params = n_sites * d * chi_mps * chi_mps
    print(f"MPS (Ï‡={chi_mps}):")
    print(f"  ParamÃ¨tres: ~{mps_params:,}")
    print(f"  ComplexitÃ© contraction: O(n Ã— d Ã— Ï‡Â²)")
    
    # PEPS (2D mapping)
    Lx, Ly = 4, 4
    chi_peps = 3
    peps_params = Lx * Ly * d * (chi_peps ** 4)
    print(f"\nPEPS 2D (Ï‡={chi_peps}):")
    print(f"  ParamÃ¨tres: ~{peps_params:,}")
    print(f"  ComplexitÃ© contraction: NP-hard (approximatif)")
    
    # MERA
    n_layers = 4
    chi_mera = 4
    mera = MERAState(n_sites, d, chi_mera, n_layers)
    mera_params = mera.count_parameters()
    print(f"\nMERA (Ï‡={chi_mera}, {n_layers} couches):")
    print(f"  ParamÃ¨tres: ~{mera_params:,}")
    print(f"  ComplexitÃ© contraction: O(n Ã— dâ´)")
    print(f"  Avantage: capture intrication multi-Ã©chelle")

compare_representations()
```

---

## Exercices

### Exercice 6.3.1
ImplÃ©mentez une fonction qui applique un disentangler et une isometry Ã  un Ã©tat de deux qubits.

### Exercice 6.3.2
CrÃ©ez un MERA pour un petit systÃ¨me (4 sites) et calculez sa norme.

### Exercice 6.3.3
Comparez le nombre de paramÃ¨tres d'un MERA avec bond_dim variable selon la couche.

---

## Points ClÃ©s Ã  Retenir

> ğŸ“Œ **MERA capture l'intrication Ã  toutes les Ã©chelles via une structure hiÃ©rarchique**

> ğŸ“Œ **Disentanglers Ã©liminent l'intrication locale, isometries projettent vers des Ã©chelles supÃ©rieures**

> ğŸ“Œ **MERA est particuliÃ¨rement adaptÃ© aux systÃ¨mes critiques**

> ğŸ“Œ **La complexitÃ© de MERA est polynomiale mais plus Ã©levÃ©e que MPS**

> ğŸ“Œ **MERA gÃ©nÃ©ralise Ã  2D et 3D mais avec complexitÃ© accrue**

---

*Section suivante : [6.4 Applications en MÃ©canique Quantique](./06_04_Mecanique_Quantique.md)*

