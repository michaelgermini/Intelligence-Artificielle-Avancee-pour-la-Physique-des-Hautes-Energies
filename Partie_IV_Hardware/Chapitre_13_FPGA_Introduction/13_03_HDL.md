# 13.3 Langages HDL (Verilog, VHDL)

---

## Introduction

Les **langages HDL** (Hardware Description Languages) permettent de d√©crire le comportement et la structure des circuits logiques. **Verilog** et **VHDL** sont les deux standards les plus utilis√©s pour le d√©veloppement FPGA.

---

## Verilog vs VHDL

### Comparaison

```python
class HDLComparison:
    """
    Comparaison entre Verilog et VHDL
    """
    
    comparison = {
        'syntax': {
            'verilog': 'Style C-like, plus concis',
            'vhdl': 'Style Pascal/Ada, plus verbeux mais explicite'
        },
        'learning_curve': {
            'verilog': 'Plus facile pour d√©butants (syntaxe famili√®re)',
            'vhdl': 'Plus strict, bonne pratique mais plus difficile'
        },
        'industry': {
            'verilog': 'Dominant en ASIC, tr√®s populaire FPGA',
            'vhdl': 'Dominant en Europe, d√©fense, a√©ronautique'
        },
        'types': {
            'verilog': 'Types limit√©s (wire, reg)',
            'vhdl': 'Syst√®me de types tr√®s riche'
        },
        'simulation': {
            'verilog': 'Excellent support',
            'vhdl': 'Excellent support'
        }
    }
    
    @staticmethod
    def display_comparison():
        """Affiche la comparaison"""
        print("\n" + "="*60)
        print("Verilog vs VHDL")
        print("="*60)
        
        for aspect, details in HDLComparison.comparison.items():
            print(f"\n{aspect.replace('_', ' ').title()}:")
            print(f"  Verilog: {details['verilog']}")
            print(f"  VHDL: {details['vhdl']}")

HDLComparison.display_comparison()
```

---

## Verilog: Les Bases

### Structure d'un Module Verilog

```verilog
// Exemple basique: Additionneur 8 bits
module adder_8bit (
    input wire [7:0] a,      // Entr√©e A, 8 bits
    input wire [7:0] b,      // Entr√©e B, 8 bits
    input wire cin,          // Carry in
    output wire [7:0] sum,   // Somme
    output wire cout         // Carry out
);

    // Description comportementale
    assign {cout, sum} = a + b + cin;

endmodule
```

### Styles de Description

```python
class VerilogStyles:
    """
    Diff√©rents styles de description en Verilog
    """
    
    styles = {
        'behavioral': {
            'description': 'Description du comportement (plus haut niveau)',
            'example': '''
always @(posedge clk) begin
    if (reset)
        q <= 0;
    else
        q <= d;
end
'''
        },
        'dataflow': {
            'description': 'Description par assignations continues',
            'example': '''
assign y = a & b;          // AND
assign z = x ? a : b;      // Multiplexer
assign sum = a + b;        // Addition
'''
        },
        'structural': {
            'description': 'Instanciation de modules (comme sch√©ma)',
            'example': '''
and_gate u1 (.a(a), .b(b), .out(and_out));
or_gate u2 (.a(c), .b(d), .out(or_out));
'''
        }
    }
    
    @staticmethod
    def display_styles():
        """Affiche les styles de description"""
        print("\n" + "="*60)
        print("Verilog Description Styles")
        print("="*60)
        
        for style, info in VerilogStyles.styles.items():
            print(f"\n{style.upper()}:")
            print(f"  {info['description']}")
            print(f"  Example:")
            print(info['example'])

VerilogStyles.display_styles()
```

---

## Exemples Verilog Pratiques

### Registre √† D√©calage (Shift Register)

```verilog
// Shift register 8 bits
module shift_register (
    input wire clk,
    input wire reset,
    input wire shift_enable,
    input wire data_in,
    output wire [7:0] data_out
);

    reg [7:0] shift_reg;
    
    always @(posedge clk) begin
        if (reset)
            shift_reg <= 8'b0;
        else if (shift_enable)
            shift_reg <= {shift_reg[6:0], data_in};
    end
    
    assign data_out = shift_reg;

endmodule
```

### Multiplexer

```verilog
// Multiplexer 4-to-1
module mux_4to1 (
    input wire [1:0] sel,
    input wire [3:0] data,
    output wire out
);

    assign out = (sel == 2'b00) ? data[0] :
                 (sel == 2'b01) ? data[1] :
                 (sel == 2'b10) ? data[2] :
                                  data[3];

endmodule
```

### Machine √† √âtats (State Machine)

```verilog
// Simple state machine example
module state_machine (
    input wire clk,
    input wire reset,
    input wire start,
    output reg [1:0] state
);

    // States
    localparam IDLE = 2'b00;
    localparam RUN  = 2'b01;
    localparam DONE = 2'b10;
    
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            case (state)
                IDLE: state <= start ? RUN : IDLE;
                RUN:  state <= DONE;
                DONE: state <= IDLE;
                default: state <= IDLE;
            endcase
    end

endmodule
```

---

## VHDL: Les Bases

### Structure d'une Entit√© VHDL

```vhdl
-- Exemple: Additionneur 8 bits en VHDL
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity adder_8bit is
    Port (
        a   : in  std_logic_vector(7 downto 0);
        b   : in  std_logic_vector(7 downto 0);
        cin : in  std_logic;
        sum : out std_logic_vector(7 downto 0);
        cout: out std_logic
    );
end adder_8bit;

architecture Behavioral of adder_8bit is
    signal temp_sum : unsigned(8 downto 0);
begin
    temp_sum <= ('0' & unsigned(a)) + unsigned(b) + ("" & cin);
    sum <= std_logic_vector(temp_sum(7 downto 0));
    cout <= temp_sum(8);
end Behavioral;
```

### Styles en VHDL

```vhdl
-- Process pour logique s√©quentielle
process(clk)
begin
    if rising_edge(clk) then
        if reset = '1' then
            q <= (others => '0');
        else
            q <= d;
        end if;
    end if;
end process;

-- Assignations concurrentes pour logique combinatoire
y <= a and b;
z <= x when (sel = '1') else y;
```

---

## Exemples VHDL Pratiques

### Registre √† D√©calage

```vhdl
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity shift_register is
    Port (
        clk          : in  std_logic;
        reset        : in  std_logic;
        shift_enable : in  std_logic;
        data_in      : in  std_logic;
        data_out     : out std_logic_vector(7 downto 0)
    );
end shift_register;

architecture Behavioral of shift_register is
    signal shift_reg : std_logic_vector(7 downto 0);
begin
    process(clk)
    begin
        if rising_edge(clk) then
            if reset = '1' then
                shift_reg <= (others => '0');
            elsif shift_enable = '1' then
                shift_reg <= shift_reg(6 downto 0) & data_in;
            end if;
        end if;
    end process;
    
    data_out <= shift_reg;
end Behavioral;
```

---

## Simulation HDL

```python
class HDLSimulation:
    """
    Concepts de simulation HDL
    """
    
    def __init__(self):
        self.testbench_concepts = {
            'testbench': 'Module qui teste le design (DUT)',
            'stimulus': 'Signaux d\'entr√©e g√©n√©r√©s',
            'monitoring': 'Observation des sorties',
            'assertions': 'V√©rifications automatiques'
        }
    
    def generate_testbench_example(self):
        """Exemple de testbench Verilog"""
        testbench_verilog = """
// Testbench pour adder_8bit
module tb_adder_8bit;

    // Signals
    reg [7:0] a, b;
    reg cin;
    wire [7:0] sum;
    wire cout;
    
    // Instantiate DUT
    adder_8bit dut (
        .a(a), .b(b), .cin(cin),
        .sum(sum), .cout(cout)
    );
    
    // Stimulus
    initial begin
        $dumpfile("adder.vcd");
        $dumpvars(0, tb_adder_8bit);
        
        // Test cases
        a = 8'h00; b = 8'h00; cin = 0;
        #10;
        
        a = 8'h05; b = 8'h03; cin = 0;
        #10;
        $display("5 + 3 = %d, cout = %b", sum, cout);
        
        a = 8'hFF; b = 8'h01; cin = 0;
        #10;
        $display("255 + 1 = %d, cout = %b", sum, cout);
        
        $finish;
    end

endmodule
"""
        return testbench_verilog

simulation = HDLSimulation()
print("\n" + "="*60)
print("HDL Simulation Concepts")
print("="*60)
for concept, description in simulation.testbench_concepts.items():
    print(f"\n{concept}: {description}")

print("\n" + "="*60)
print("Example Testbench (Verilog)")
print("="*60)
print(simulation.generate_testbench_example())
```

---

## Bonnes Pratiques HDL

```python
class HDLBestPractices:
    """
    Bonnes pratiques pour d√©veloppement HDL
    """
    
    practices = {
        'naming': {
            'conventions': [
                'Noms significatifs et descriptifs',
                'Consistance dans les conventions',
                'Pr√©fixes pour types (clk_, rst_, data_)'
            ],
            'example': 'clk_50MHz, reset_n, data_in[7:0]'
        },
        'synchronous_design': {
            'rules': [
                'Utiliser un seul clock domain par design si possible',
                'Tous les FF synchronis√©s sur m√™me edge',
                '√âviter gated clocks (sauf si n√©cessaire)'
            ],
            'importance': 'Critique pour timing closure'
        },
        'reset_strategy': {
            'types': ['Synchronous reset', 'Asynchronous reset'],
            'recommendation': 'Synchronous reset g√©n√©ralement pr√©f√©r√©'
        },
        'combinational_logic': {
            'rules': [
                'Tous les chemins couverts (pas de latches)',
                '√âviter loops combinatoires',
                'Utiliser case statements avec default'
            ]
        },
        'hierarchy': {
            'benefits': [
                'R√©utilisabilit√©',
                'Maintenabilit√©',
                'Testabilit√©'
            ]
        }
    }
    
    @staticmethod
    def display_practices():
        """Affiche les bonnes pratiques"""
        print("\n" + "="*60)
        print("HDL Best Practices")
        print("="*60)
        
        for practice, info in HDLBestPractices.practices.items():
            print(f"\n{practice.replace('_', ' ').title()}:")
            if isinstance(info, dict):
                for key, value in info.items():
                    if isinstance(value, list):
                        print(f"  {key}:")
                        for item in value:
                            print(f"    ‚Ä¢ {item}")
                    else:
                        print(f"  {key}: {value}")
            else:
                print(f"  {info}")

HDLBestPractices.display_practices()
```

---

## Exercices

### Exercice 13.3.1
Impl√©mentez en Verilog un compteur 8 bits avec enable et reset synchrones.

### Exercice 13.3.2
√âcrivez un testbench complet pour tester un multiplexer 8-to-1 avec toutes les combinaisons possibles.

---

## Points Cl√©s √† Retenir

> üìå **Verilog: Style C-like, concis, populaire**

> üìå **VHDL: Style Pascal, verbeux mais strict et explicite**

> üìå **Trois styles: Behavioral, Dataflow, Structural**

> üìå **Testbench essentiel pour validation**

> üìå **Bonnes pratiques critiques pour timing et maintenabilit√©**

---

*Section suivante : [13.4 High-Level Synthesis (HLS)](./13_04_HLS.md)*

