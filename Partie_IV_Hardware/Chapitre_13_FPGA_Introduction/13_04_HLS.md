# 13.4 High-Level Synthesis (HLS)

---

## Introduction

Le **High-Level Synthesis (HLS)** permet de dÃ©velopper pour FPGA en utilisant des langages de haut niveau (C/C++/SystemC) au lieu de HDL. Cela accÃ©lÃ¨re le dÃ©veloppement tout en permettant des optimisations automatiques.

---

## Concept HLS

### Workflow HLS

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HLS Design Flow                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  C/C++ Code                                                     â”‚
â”‚     â”‚                                                           â”‚
â”‚     â–¼                                                           â”‚
â”‚  HLS Compiler (Vitis HLS, Intel HLS)                          â”‚
â”‚     â”‚                                                           â”‚
â”‚     â”œâ”€ Scheduling: DÃ©termine l'ordre des opÃ©rations           â”‚
â”‚     â”œâ”€ Binding: Associe opÃ©rations Ã  ressources hardware      â”‚
â”‚     â””â”€ Allocation: Alloue les ressources                       â”‚
â”‚     â”‚                                                           â”‚
â”‚     â–¼                                                           â”‚
â”‚  RTL (Verilog/VHDL)                                            â”‚
â”‚     â”‚                                                           â”‚
â”‚     â–¼                                                           â”‚
â”‚  FPGA Synthesis Tools                                          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Avantages et Limitations

```python
class HLS_Overview:
    """
    Vue d'ensemble du High-Level Synthesis
    """
    
    advantages = [
        'DÃ©veloppement plus rapide (C/C++ plus familier)',
        'Abstraction Ã©levÃ©e (algorithmes, pas hardware)',
        'Meilleure maintenabilitÃ© du code',
        'Optimisations automatiques par le compilateur',
        'Prototypage rapide',
        'RÃ©utilisabilitÃ© du code'
    ]
    
    limitations = [
        'Moins de contrÃ´le prÃ©cis sur le hardware',
        'Peut Ãªtre moins optimal que HDL manuel',
        'Courbe d\'apprentissage pour directives',
        'Pas tous les designs sont adaptÃ©s',
        'Debugging parfois plus difficile'
    ]
    
    use_cases = {
        'good': [
            'Algorithmes numÃ©riques (FFT, filtres)',
            'Traitement de signal',
            'Vision par ordinateur',
            'Machine Learning inference',
            'Prototypage rapide'
        ],
        'not_optimal': [
            'Interfaces trÃ¨s spÃ©cifiques',
            'ContrÃ´le fin des ressources',
            'Designs trÃ¨s critiques en timing'
        ]
    }
    
    @staticmethod
    def display_overview():
        """Affiche la vue d'ensemble"""
        print("\n" + "="*60)
        print("High-Level Synthesis Overview")
        print("="*60)
        
        print("\nAdvantages:")
        for adv in HLS_Overview.advantages:
            print(f"  + {adv}")
        
        print("\nLimitations:")
        for lim in HLS_Overview.limitations:
            print(f"  - {lim}")
        
        print("\nGood Use Cases:")
        for use_case in HLS_Overview.use_cases['good']:
            print(f"  âœ“ {use_case}")
        
        print("\nLess Optimal Use Cases:")
        for use_case in HLS_Overview.use_cases['not_optimal']:
            print(f"  âœ— {use_case}")

HLS_Overview.display_overview()
```

---

## Exemple Basique en C/C++

### Fonction Simple

```cpp
// Exemple HLS: Multiplication matrice-vecteur
#include <ap_int.h>

#define N 8
#define M 16

void matrix_vector_mult(
    ap_int<16> A[M][N],      // Matrice MxN
    ap_int<16> x[N],         // Vecteur N
    ap_int<32> y[M]          // RÃ©sultat M
) {
    #pragma HLS INTERFACE ap_fifo port=A
    #pragma HLS INTERFACE ap_fifo port=x
    #pragma HLS INTERFACE ap_fifo port=y
    
    // Unroll loops pour parallÃ©lisme
    #pragma HLS ARRAY_PARTITION variable=A complete dim=2
    #pragma HLS ARRAY_PARTITION variable=x complete
    
    Row_Loop: for (int i = 0; i < M; i++) {
        #pragma HLS PIPELINE II=1
        
        ap_int<32> sum = 0;
        
        Col_Loop: for (int j = 0; j < N; j++) {
            #pragma HLS UNROLL
            sum += A[i][j] * x[j];
        }
        
        y[i] = sum;
    }
}
```

---

## Directives HLS

```python
class HLSDirectives:
    """
    Directives HLS communes
    """
    
    directives = {
        'interface': {
            'name': '#pragma HLS INTERFACE',
            'purpose': 'SpÃ©cifie l\'interface du module',
            'options': ['ap_fifo', 'ap_memory', 'ap_bus', 's_axilite'],
            'example': '#pragma HLS INTERFACE ap_fifo port=data'
        },
        'pipeline': {
            'name': '#pragma HLS PIPELINE',
            'purpose': 'Pipeline une boucle pour amÃ©liorer throughput',
            'options': ['II=1', 'II=2', 'off'],
            'example': '#pragma HLS PIPELINE II=1'
        },
        'unroll': {
            'name': '#pragma HLS UNROLL',
            'purpose': 'DÃ©roule une boucle pour parallÃ©lisme',
            'options': ['factor=4', 'complete'],
            'example': '#pragma HLS UNROLL factor=4'
        },
        'array_partition': {
            'name': '#pragma HLS ARRAY_PARTITION',
            'purpose': 'Partitionne un tableau en mÃ©moire distribuÃ©e',
            'options': ['complete', 'cyclic', 'block'],
            'example': '#pragma HLS ARRAY_PARTITION variable=A complete dim=2'
        },
        'dataflow': {
            'name': '#pragma HLS DATAFLOW',
            'purpose': 'Permet exÃ©cution parallÃ¨le de fonctions',
            'example': '#pragma HLS DATAFLOW'
        },
        'inline': {
            'name': '#pragma HLS INLINE',
            'purpose': 'In-line une fonction (pas de hiÃ©rarchie)',
            'example': '#pragma HLS INLINE'
        },
        'allocation': {
            'name': '#pragma HLS ALLOCATION',
            'purpose': 'Limite le nombre d\'instances d\'opÃ©rateurs',
            'example': '#pragma HLS ALLOCATION instances=mul limit=4'
        }
    }
    
    @staticmethod
    def display_directives():
        """Affiche les directives HLS"""
        print("\n" + "="*60)
        print("Common HLS Directives")
        print("="*60)
        
        for directive, info in HLSDirectives.directives.items():
            print(f"\n{info['name']}:")
            print(f"  Purpose: {info['purpose']}")
            if 'options' in info:
                print(f"  Options: {', '.join(info['options'])}")
            print(f"  Example: {info['example']}")

HLSDirectives.display_directives()
```

---

## Exemple AvancÃ©: Convolution 2D

```cpp
// Convolution 2D optimisÃ©e avec HLS
#include <ap_int.h>

#define IMG_WIDTH 224
#define IMG_HEIGHT 224
#define KERNEL_SIZE 3
#define CHANNELS 3

void conv2d(
    ap_int<8> img[IMG_HEIGHT][IMG_WIDTH][CHANNELS],
    ap_int<8> kernel[KERNEL_SIZE][KERNEL_SIZE][CHANNELS],
    ap_int<16> output[IMG_HEIGHT-2][IMG_WIDTH-2]
) {
    // Interface specifications
    #pragma HLS INTERFACE ap_fifo port=img
    #pragma HLS INTERFACE ap_fifo port=kernel
    #pragma HLS INTERFACE ap_fifo port=output
    
    // Partition arrays for parallel access
    #pragma HLS ARRAY_PARTITION variable=kernel complete dim=0
    
    // Pipeline the outer loops
    #pragma HLS PIPELINE II=1
    
    Row_Loop: for (int i = 1; i < IMG_HEIGHT - 1; i++) {
        Col_Loop: for (int j = 1; j < IMG_WIDTH - 1; j++) {
            #pragma HLS PIPELINE II=1
            
            ap_int<24> sum = 0;
            
            // Kernel loops
            Kernel_Row: for (int ki = 0; ki < KERNEL_SIZE; ki++) {
                #pragma HLS UNROLL
                Kernel_Col: for (int kj = 0; kj < KERNEL_SIZE; kj++) {
                    #pragma HLS UNROLL
                    Channel_Loop: for (int c = 0; c < CHANNELS; c++) {
                        #pragma HLS UNROLL
                        sum += img[i + ki - 1][j + kj - 1][c] * 
                               kernel[ki][kj][c];
                    }
                }
            }
            
            output[i-1][j-1] = sum;
        }
    }
}
```

---

## Dataflow

```cpp
// Exemple de dataflow: pipeline de traitement
#include <ap_int.h>

void stage1(ap_int<16> *in, ap_int<16> *out) {
    #pragma HLS INTERFACE ap_fifo port=in
    #pragma HLS INTERFACE ap_fifo port=out
    *out = *in * 2;
}

void stage2(ap_int<16> *in, ap_int<16> *out) {
    #pragma HLS INTERFACE ap_fifo port=in
    #pragma HLS INTERFACE ap_fifo port=out
    *out = *in + 10;
}

void stage3(ap_int<16> *in, ap_int<16> *out) {
    #pragma HLS INTERFACE ap_fifo port=in
    #pragma HLS INTERFACE ap_fifo port=out
    *out = *in / 2;
}

void processing_pipeline(
    ap_int<16> input_stream[100],
    ap_int<16> output_stream[100]
) {
    #pragma HLS DATAFLOW
    
    ap_int<16> intermediate1[100];
    ap_int<16> intermediate2[100];
    
    // Ces fonctions s'exÃ©cutent en parallÃ¨le (pipeline)
    stage1(input_stream, intermediate1);
    stage2(intermediate1, intermediate2);
    stage3(intermediate2, output_stream);
}
```

---

## Optimisations HLS

```python
class HLSOptimizations:
    """
    Techniques d'optimisation HLS
    """
    
    techniques = {
        'pipelining': {
            'concept': 'ExÃ©cution en pipeline pour amÃ©liorer throughput',
            'tradeoff': 'Augmente latency mais amÃ©liore throughput',
            'directive': '#pragma HLS PIPELINE II=1',
            'example': 'Traiter une nouvelle donnÃ©e chaque cycle'
        },
        'loop_unrolling': {
            'concept': 'DÃ©rouler les boucles pour parallÃ©lisme',
            'tradeoff': 'Utilise plus de ressources (LUTs, DSPs)',
            'directive': '#pragma HLS UNROLL',
            'example': 'Calculer 4 itÃ©rations en parallÃ¨le'
        },
        'array_partitioning': {
            'concept': 'Diviser les tableaux en mÃ©moires plus petites',
            'tradeoff': 'Permet accÃ¨s parallÃ¨le mais utilise plus de BRAM',
            'directive': '#pragma HLS ARRAY_PARTITION',
            'example': 'Partitionner pour accÃ¨s simultanÃ©s'
        },
        'dataflow': {
            'concept': 'Pipeline au niveau fonction',
            'tradeoff': 'ExÃ©cution parallÃ¨le des fonctions',
            'directive': '#pragma HLS DATAFLOW',
            'example': 'Pipeline de traitement multi-Ã©tapes'
        },
        'resource_sharing': {
            'concept': 'Partager opÃ©rateurs entre itÃ©rations',
            'tradeoff': 'RÃ©duit ressources mais augmente latency',
            'directive': '#pragma HLS RESOURCE',
            'example': 'Partager un multiplicateur'
        }
    }
    
    @staticmethod
    def display_optimizations():
        """Affiche les techniques d'optimisation"""
        print("\n" + "="*60)
        print("HLS Optimization Techniques")
        print("="*60)
        
        for tech, info in HLSOptimizations.techniques.items():
            print(f"\n{tech.replace('_', ' ').title()}:")
            print(f"  Concept: {info['concept']}")
            print(f"  Tradeoff: {info['tradeoff']}")
            print(f"  Directive: {info['directive']}")
            print(f"  Example: {info['example']}")

HLSOptimizations.display_optimizations()
```

---

## Vitis HLS (Xilinx)

```python
class VitisHLS:
    """
    Outil HLS de Xilinx: Vitis HLS
    """
    
    features = {
        'language_support': ['C', 'C++', 'SystemC'],
        'target_devices': 'Tous les FPGA Xilinx/AMD',
        'integration': 'IntÃ©grÃ© dans Vivado',
        'simulation': 'C simulation, C/RTL co-simulation',
        'synthesis': 'RTL generation automatique'
    }
    
    workflow_steps = [
        '1. Write C/C++ code with pragmas',
        '2. C Simulation (validate algorithm)',
        '3. C Synthesis (generate RTL)',
        '4. C/RTL Co-simulation (verify RTL)',
        '5. Export IP for Vivado'
    ]
    
    @staticmethod
    def display_info():
        """Affiche les informations sur Vitis HLS"""
        print("\n" + "="*60)
        print("Vitis HLS (Xilinx)")
        print("="*60)
        
        print("\nFeatures:")
        for feature, value in VitisHLS.features.items():
            if isinstance(value, list):
                print(f"  {feature}: {', '.join(value)}")
            else:
                print(f"  {feature}: {value}")
        
        print("\nWorkflow:")
        for step in VitisHLS.workflow_steps:
            print(f"  {step}")

VitisHLS.display_info()
```

---

## Rapport HLS

```python
class HLSReport:
    """
    Exemple de rapport de synthÃ¨se HLS
    """
    
    def generate_example_report(self):
        """GÃ©nÃ¨re un rapport typique"""
        report = {
            'timing': {
                'clock_period_ns': 5.0,
                'target_clock_mhz': 200,
                'achieved_clock_mhz': 195,
                'meets_timing': True
            },
            'resources': {
                'lut': {'used': 3421, 'available': 53000, 'percent': 6.5},
                'ff': {'used': 2143, 'available': 106000, 'percent': 2.0},
                'bram': {'used': 8, 'available': 560, 'percent': 1.4},
                'dsp': {'used': 24, 'available': 1200, 'percent': 2.0}
            },
            'latency': {
                'min': 120,
                'max': 120,
                'interval': 1  # Initiation Interval
            },
            'throughput': {
                'samples_per_second': 200_000_000  # 200 MHz * 1 sample/cycle
            }
        }
        
        print("\n" + "="*60)
        print("HLS Synthesis Report Example")
        print("="*60)
        
        print("\nTiming:")
        timing = report['timing']
        print(f"  Clock Period: {timing['clock_period_ns']} ns")
        print(f"  Target: {timing['target_clock_mhz']} MHz")
        print(f"  Achieved: {timing['achieved_clock_mhz']} MHz")
        print(f"  Meets Timing: {timing['meets_timing']}")
        
        print("\nResource Usage:")
        for resource, info in report['resources'].items():
            print(f"  {resource.upper()}: "
                  f"{info['used']:,}/{info['available']:,} "
                  f"({info['percent']:.1f}%)")
        
        print("\nLatency:")
        latency = report['latency']
        print(f"  Min: {latency['min']} cycles")
        print(f"  Max: {latency['max']} cycles")
        print(f"  Interval: {latency['interval']} cycles")
        
        print("\nThroughput:")
        throughput = report['throughput']
        print(f"  {throughput['samples_per_second']/1e6:.1f} MSamples/s")
        
        return report

hls_report = HLSReport()
hls_report.generate_example_report()
```

---

## Exercices

### Exercice 13.4.1
Ã‰crivez une fonction HLS pour calculer la norme L2 d'un vecteur avec directives d'optimisation appropriÃ©es.

### Exercice 13.4.2
ImplÃ©mentez un filtre FIR (Finite Impulse Response) avec dataflow entre les diffÃ©rentes Ã©tapes.

---

## Points ClÃ©s Ã  Retenir

> ğŸ“Œ **HLS permet dÃ©veloppement C/C++ au lieu de HDL**

> ğŸ“Œ **Directives pragmas contrÃ´lent la synthÃ¨se**

> ğŸ“Œ **Pipelining amÃ©liore throughput**

> ğŸ“Œ **Unrolling permet parallÃ©lisme**

> ğŸ“Œ **Dataflow permet pipelines multi-Ã©tapes**

> ğŸ“Œ **Optimisations tradeoffs ressources/latency/throughput**

---

*Section suivante : [13.5 Outils de DÃ©veloppement](./13_05_Outils.md)*

