# 24.5 InterfaÃ§age Python/C++ (pybind11)

---

## Introduction

**pybind11** est une bibliothÃ¨que header-only qui simplifie la crÃ©ation de bindings Python pour code C++. Elle permet d'exposer facilement fonctions, classes, et types C++ Ã  Python, combinant facilitÃ© d'utilisation Python avec performance C++.

---

## Installation

### Setup

```cpp
/*
Installation:
- pip install pybind11
- Ou via CMake: find_package(pybind11 REQUIRED)

Structure projet:
project/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ module.cpp
â”œâ”€â”€ CMakeLists.txt
â””â”€â”€ setup.py (optionnel)
*/
```

---

## Fonctions Simples

### Exposer Fonctions C++

```cpp
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>

namespace py = pybind11;

// Fonction simple
double add(double a, double b) {
    return a + b;
}

// Fonction avec arguments multiples
int multiply(int a, int b, int c = 1) {
    return a * b * c;
}

// Fonction avec overload
int overloaded_function(int x) {
    return x * 2;
}

double overloaded_function(double x) {
    return x * 2.5;
}

PYBIND11_MODULE(my_module, m) {
    m.doc() = "Module d'exemple pybind11";
    
    // Exposer fonction simple
    m.def("add", &add, "Addition de deux nombres",
          py::arg("a"), py::arg("b"));
    
    // Avec arguments par dÃ©faut
    m.def("multiply", &multiply, "Multiplication",
          py::arg("a"), py::arg("b"), py::arg("c") = 1);
    
    // Overload
    m.def("overloaded_function", 
          py::overload_cast<int>(&overloaded_function),
          "Overload pour int");
    m.def("overloaded_function",
          py::overload_cast<double>(&overloaded_function),
          "Overload pour double");
}
```

---

## Classes C++

### Exposer Classes

```cpp
#include <pybind11/pybind11.h>
#include <string>
#include <vector>

class Vector {
private:
    std::vector<double> data_;

public:
    Vector() {}
    Vector(size_t size) : data_(size) {}
    Vector(const std::vector<double>& data) : data_(data) {}
    
    double& operator[](size_t i) { return data_[i]; }
    const double& operator[](size_t i) const { return data_[i]; }
    
    size_t size() const { return data_.size(); }
    
    void append(double value) { data_.push_back(value); }
    
    double norm() const {
        double sum = 0.0;
        for (double val : data_) {
            sum += val * val;
        }
        return std::sqrt(sum);
    }
    
    Vector operator+(const Vector& other) const {
        Vector result(data_);
        for (size_t i = 0; i < std::min(result.size(), other.size()); ++i) {
            result[i] += other[i];
        }
        return result;
    }
    
    std::string __repr__() const {
        return "Vector(size=" + std::to_string(data_.size()) + ")";
    }
};

PYBIND11_MODULE(vector_module, m) {
    py::class_<Vector>(m, "Vector")
        .def(py::init<>())
        .def(py::init<size_t>())
        .def(py::init<const std::vector<double>&>())
        .def("__getitem__", [](const Vector& v, size_t i) {
            if (i >= v.size()) throw py::index_error();
            return v[i];
        })
        .def("__setitem__", [](Vector& v, size_t i, double value) {
            if (i >= v.size()) throw py::index_error();
            v[i] = value;
        })
        .def("__len__", &Vector::size)
        .def("append", &Vector::append)
        .def("norm", &Vector::norm)
        .def("__add__", &Vector::operator+)
        .def("__repr__", &Vector::__repr__);
}
```

---

## NumPy Arrays

### InterfaÃ§age avec NumPy

```cpp
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <algorithm>

namespace py = pybind11;

// Fonction qui accepte NumPy array
double sum_array(py::array_t<double> input) {
    auto buf = input.request();
    double* ptr = static_cast<double*>(buf.ptr);
    
    double sum = 0.0;
    for (size_t i = 0; i < buf.size; ++i) {
        sum += ptr[i];
    }
    return sum;
}

// Fonction qui retourne NumPy array
py::array_t<double> multiply_array(py::array_t<double> input, double factor) {
    auto buf = input.request();
    
    // CrÃ©er array de sortie
    auto result = py::array_t<double>(buf.size);
    auto result_buf = result.request();
    
    double* input_ptr = static_cast<double*>(buf.ptr);
    double* result_ptr = static_cast<double*>(result_buf.ptr);
    
    for (size_t i = 0; i < buf.size; ++i) {
        result_ptr[i] = input_ptr[i] * factor;
    }
    
    return result;
}

// Multiplication matricielle (2D array)
py::array_t<double> matrix_multiply(py::array_t<double> A, 
                                    py::array_t<double> B) {
    auto buf_A = A.request();
    auto buf_B = B.request();
    
    if (buf_A.ndim != 2 || buf_B.ndim != 2) {
        throw std::runtime_error("Arrays must be 2D");
    }
    
    size_t rows_A = buf_A.shape[0];
    size_t cols_A = buf_A.shape[1];
    size_t rows_B = buf_B.shape[0];
    size_t cols_B = buf_B.shape[1];
    
    if (cols_A != rows_B) {
        throw std::runtime_error("Matrix dimensions incompatible");
    }
    
    // CrÃ©er rÃ©sultat
    auto result = py::array_t<double>({rows_A, cols_B});
    auto buf_result = result.request();
    
    double* A_ptr = static_cast<double*>(buf_A.ptr);
    double* B_ptr = static_cast<double*>(buf_B.ptr);
    double* result_ptr = static_cast<double*>(buf_result.ptr);
    
    // Multiplication
    for (size_t i = 0; i < rows_A; ++i) {
        for (size_t j = 0; j < cols_B; ++j) {
            double sum = 0.0;
            for (size_t k = 0; k < cols_A; ++k) {
                sum += A_ptr[i * cols_A + k] * B_ptr[k * cols_B + j];
            }
            result_ptr[i * cols_B + j] = sum;
        }
    }
    
    return result;
}

PYBIND11_MODULE(numpy_module, m) {
    m.def("sum_array", &sum_array, "Somme Ã©lÃ©ments array");
    m.def("multiply_array", &multiply_array, 
          "Multiplie array par facteur");
    m.def("matrix_multiply", &matrix_multiply, 
          "Multiplication matricielle");
}
```

---

## STL Containers

### Exposer Types STL

```cpp
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <vector>
#include <map>
#include <string>

// Fonction avec vector
double sum_vector(const std::vector<double>& vec) {
    double sum = 0.0;
    for (double val : vec) {
        sum += val;
    }
    return sum;
}

// Fonction qui retourne vector
std::vector<int> create_range(int start, int end) {
    std::vector<int> result;
    for (int i = start; i < end; ++i) {
        result.push_back(i);
    }
    return result;
}

// Fonction avec map
std::map<std::string, double> create_dict(
    const std::vector<std::string>& keys,
    const std::vector<double>& values) {
    
    std::map<std::string, double> result;
    for (size_t i = 0; i < std::min(keys.size(), values.size()); ++i) {
        result[keys[i]] = values[i];
    }
    return result;
}

PYBIND11_MODULE(stl_module, m) {
    m.def("sum_vector", &sum_vector);
    m.def("create_range", &create_range);
    m.def("create_dict", &create_dict);
}
```

---

## CMake Integration

### Configuration CMake

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.12)
project(my_python_module)

find_package(pybind11 REQUIRED)

# CrÃ©er module Python
pybind11_add_module(my_module src/module.cpp)

# Compiler flags
target_compile_features(my_module PRIVATE cxx_std_17)
target_compile_definitions(my_module PRIVATE VERSION_INFO="${EXAMPLE_VERSION_INFO}")

# Lier bibliothÃ¨ques si nÃ©cessaire
# target_link_libraries(my_module PRIVATE some_library)
```

---

## Exemple Complet: Module Matrix

### Classe Matrix ComplÃ¨te

```cpp
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <memory>
#include <cmath>

namespace py = pybind11;

class Matrix {
private:
    size_t rows_, cols_;
    std::unique_ptr<double[]> data_;

public:
    Matrix(size_t rows, size_t cols) 
        : rows_(rows), cols_(cols),
          data_(std::make_unique<double[]>(rows * cols)) {}
    
    Matrix(py::array_t<double> arr) {
        auto buf = arr.request();
        if (buf.ndim != 2) {
            throw std::runtime_error("Array must be 2D");
        }
        rows_ = buf.shape[0];
        cols_ = buf.shape[1];
        data_ = std::make_unique<double[]>(rows_ * cols_);
        
        double* ptr = static_cast<double*>(buf.ptr);
        std::copy(ptr, ptr + rows_ * cols_, data_.get());
    }
    
    double& operator()(size_t i, size_t j) {
        return data_[i * cols_ + j];
    }
    
    double operator()(size_t i, size_t j) const {
        return data_[i * cols_ + j];
    }
    
    py::array_t<double> to_numpy() const {
        auto result = py::array_t<double>({rows_, cols_});
        auto buf = result.request();
        double* ptr = static_cast<double*>(buf.ptr);
        std::copy(data_.get(), data_.get() + rows_ * cols_, ptr);
        return result;
    }
    
    Matrix operator*(const Matrix& other) const {
        if (cols_ != other.rows_) {
            throw std::runtime_error("Matrix dimensions incompatible");
        }
        
        Matrix result(rows_, other.cols_);
        
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < other.cols_; ++j) {
                double sum = 0.0;
                for (size_t k = 0; k < cols_; ++k) {
                    sum += (*this)(i, k) * other(k, j);
                }
                result(i, j) = sum;
            }
        }
        
        return result;
    }
    
    size_t rows() const { return rows_; }
    size_t cols() const { return cols_; }
};

PYBIND11_MODULE(matrix_module, m) {
    py::class_<Matrix>(m, "Matrix")
        .def(py::init<size_t, size_t>())
        .def(py::init<py::array_t<double>>())
        .def("__call__", [](Matrix& m, size_t i, size_t j) -> double& {
            return m(i, j);
        })
        .def("to_numpy", &Matrix::to_numpy)
        .def("__mul__", &Matrix::operator*)
        .def_property_readonly("rows", &Matrix::rows)
        .def_property_readonly("cols", &Matrix::cols);
}

// Utilisation Python:
// import matrix_module
// m = matrix_module.Matrix(3, 3)
// m(0, 0) = 1.0
// arr = m.to_numpy()
```

---

## Exercices

### Exercice 24.5.1
CrÃ©ez un module pybind11 qui expose une fonction C++ simple (ex: calcul de norme).

### Exercice 24.5.2
Exposez une classe C++ avec mÃ©thodes et opÃ©rateurs Ã  Python.

### Exercice 24.5.3
CrÃ©ez une fonction qui accepte et retourne des NumPy arrays 2D.

### Exercice 24.5.4
IntÃ©grez une bibliothÃ¨que C++ (ex: Eigen) avec pybind11 et exposez-la Ã  Python.

---

## Points ClÃ©s Ã  Retenir

> ðŸ“Œ **pybind11 simplifie crÃ©ation de bindings Python/C++**

> ðŸ“Œ **Support automatique pour types STL et NumPy**

> ðŸ“Œ **Exposition classes C++ avec interface Python naturelle**

> ðŸ“Œ **IntÃ©gration CMake facilite compilation**

> ðŸ“Œ **Performance C++ accessible depuis Python**

> ðŸ“Œ **Combiner facilitÃ© Python avec performance C++**

---

*Section prÃ©cÃ©dente : [24.4 ParallÃ©lisation](./24_04_Parallelisation.md)*

