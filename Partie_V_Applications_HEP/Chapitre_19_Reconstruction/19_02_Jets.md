# 19.2 Identification de Jets

---

## Introduction

Les **jets** sont des sprays de particules produits par la hadronisation de quarks ou gluons. L'identification et la classification des jets sont cruciales pour la physique des hautes √©nergies, permettant de distinguer diff√©rents types de jets (quark vs gluon, b-jets, c-jets, etc.).

Le machine learning a r√©volutionn√© l'identification de jets en utilisant des features de haut niveau ou m√™me les images de d√©tecteur directement.

---

## Clustering de Jets

### Algorithmes de Clustering

```python
import numpy as np
import torch
import torch.nn as nn
from typing import List, Dict, Tuple

class JetClustering:
    """
    Algorithmes de clustering pour reconstruction de jets
    """
    
    def __init__(self):
        self.clustering_algorithms = {
            'anti_kt': {
                'description': 'Anti-kT algorithm (standard au LHC)',
                'distance_metric': 'kt_distance',
                'parameters': {'R': 0.4}  # Jet radius
            },
            'kt': {
                'description': 'kT algorithm',
                'distance_metric': 'kt_distance',
                'parameters': {'R': 0.4}
            },
            'ca': {
                'description': 'Cambridge-Aachen algorithm',
                'distance_metric': 'angular_distance',
                'parameters': {'R': 0.4}
            }
        }
    
    def anti_kt_clustering(self, particles: np.ndarray, R: float = 0.4):
        """
        Clustering anti-kT
        
        Args:
            particles: (n_particles, 4) [pt, eta, phi, E]
            R: Jet radius
        
        Returns:
            List de jets (chaque jet = indices de particules)
        """
        n = len(particles)
        if n == 0:
            return []
        
        # Matrice de distances
        distances = np.zeros((n, n))
        beam_distances = np.zeros(n)
        
        for i in range(n):
            # Distance au faisceau
            beam_distances[i] = particles[i][0] ** (-2)  # 1/pt^2
            
            for j in range(i + 1, n):
                # Distance entre particules
                deta = particles[i][1] - particles[j][1]  # ŒîŒ∑
                dphi = self._delta_phi(particles[i][2], particles[j][2])  # ŒîœÜ
                dij = min(particles[i][0] ** (-2), particles[j][0] ** (-2)) * (deta**2 + dphi**2) / R**2
                
                distances[i, j] = dij
                distances[j, i] = dij
        
        # Algorithme clustering (simplifi√©)
        jets = []
        used = np.zeros(n, dtype=bool)
        
        # Clustering it√©ratif (simplifi√©)
        while not used.all():
            # Trouver minimum
            min_dist = float('inf')
            min_i, min_j = -1, -1
            min_beam = float('inf')
            min_beam_i = -1
            
            for i in range(n):
                if used[i]:
                    continue
                
                if beam_distances[i] < min_beam:
                    min_beam = beam_distances[i]
                    min_beam_i = i
                
                for j in range(i + 1, n):
                    if used[j]:
                        continue
                    if distances[i, j] < min_dist:
                        min_dist = distances[i, j]
                        min_i, min_j = i, j
            
            # Si distance particule-particule < distance faisceau, combiner
            if min_dist < min_beam and min_i >= 0:
                # Combiner particules (simplifi√©: ajouter au m√™me jet)
                jet = [min_i, min_j]
                used[min_i] = True
                used[min_j] = True
                jets.append(jet)
            else:
                # Cr√©er jet avec cette particule
                jets.append([min_beam_i])
                used[min_beam_i] = True
        
        return jets
    
    def _delta_phi(self, phi1: float, phi2: float) -> float:
        """Calcule ŒîœÜ (wrap around √† 2œÄ)"""
        dphi = phi1 - phi2
        while dphi > np.pi:
            dphi -= 2 * np.pi
        while dphi < -np.pi:
            dphi += 2 * np.pi
        return abs(dphi)
    
    def compute_jet_properties(self, particles: np.ndarray, jet_indices: List[int]) -> Dict:
        """
        Calcule propri√©t√©s d'un jet depuis ses particules constituantes
        """
        jet_particles = particles[jet_indices]
        
        # Somme vectorielle
        px_sum = np.sum(jet_particles[:, 0] * np.cos(jet_particles[:, 2]))
        py_sum = np.sum(jet_particles[:, 0] * np.sin(jet_particles[:, 2]))
        pz_sum = np.sum(jet_particles[:, 0] * np.sinh(jet_particles[:, 1]))
        E_sum = np.sum(jet_particles[:, 3])
        
        # pT, Œ∑, œÜ du jet
        pt = np.sqrt(px_sum**2 + py_sum**2)
        phi = np.arctan2(py_sum, px_sum)
        p = np.sqrt(px_sum**2 + py_sum**2 + pz_sum**2)
        eta = 0.5 * np.log((p + pz_sum) / (p - pz_sum)) if p > abs(pz_sum) else 0.0
        
        # Masse invariante
        mass = np.sqrt(max(0, E_sum**2 - p**2))
        
        return {
            'pt': pt,
            'eta': eta,
            'phi': phi,
            'mass': mass,
            'energy': E_sum,
            'n_constituents': len(jet_indices)
        }

# Exemple clustering
clustering = JetClustering()

# Simuler particules
n_particles = 50
particles = np.random.rand(n_particles, 4)
particles[:, 0] *= 50  # pT en GeV
particles[:, 1] = np.random.uniform(-2, 2, n_particles)  # Œ∑
particles[:, 2] = np.random.uniform(-np.pi, np.pi, n_particles)  # œÜ
particles[:, 3] = particles[:, 0] * np.cosh(particles[:, 1])  # E

jets = clustering.anti_kt_clustering(particles, R=0.4)

print(f"\nClustering de Jets:")
print(f"  Particules: {n_particles}")
print(f"  Jets trouv√©s: {len(jets)}")

# Calculer propri√©t√©s
jet_properties = clustering.compute_jet_properties(particles, jets[0])
print(f"  Jet 0: pT={jet_properties['pt']:.1f} GeV, "
      f"mass={jet_properties['mass']:.1f} GeV, "
      f"n_constituents={jet_properties['n_constituents']}")
```

---

## Features de Jets

### Caract√©ristiques pour Classification

```python
class JetFeatures:
    """
    Calcul de features pour classification de jets
    """
    
    def compute_kinematic_features(self, particles: np.ndarray, 
                                   jet_particles: np.ndarray) -> Dict:
        """
        Features cin√©matiques de base
        """
        pt = np.sum(particles[:, 0])
        eta = np.mean(particles[:, 1])
        phi = np.mean(particles[:, 2])
        mass = self._compute_invariant_mass(particles)
        
        return {
            'pt': pt,
            'eta': eta,
            'phi': phi,
            'mass': mass,
            'energy': np.sum(particles[:, 3])
        }
    
    def compute_shape_features(self, particles: np.ndarray, 
                              jet_axis: np.ndarray) -> Dict:
        """
        Features de forme (width, etc.)
        """
        # Width: moyenne des distances ŒîR des particules √† l'axe du jet
        pt_total = np.sum(particles[:, 0])
        
        deltas = []
        for p in particles:
            deta = p[1] - jet_axis[1]
            dphi = self._delta_phi(p[2], jet_axis[2])
            dr = np.sqrt(deta**2 + dphi**2)
            deltas.append(dr * p[0])  # Pond√©r√© par pT
        
        width = np.sum(deltas) / pt_total if pt_total > 0 else 0
        
        # pT_D: dispersion pT
        pt_values = particles[:, 0]
        pt_D = np.sqrt(np.sum(pt_values**2)) / pt_total if pt_total > 0 else 0
        
        return {
            'width': width,
            'pt_D': pt_D
        }
    
    def compute_nsubjettiness(self, particles: np.ndarray, 
                             n: int = 1, beta: float = 1.0) -> float:
        """
        N-subjettiness: mesure si jet ressemble √† N sous-jets
        """
        # Simplifi√©: utilise clustering kT pour trouver N axes
        # En pratique: utiliser FastJet
        
        if len(particles) < n:
            return 0.0
        
        # Approximation: utiliser axes des N particules avec plus haut pT
        sorted_indices = np.argsort(particles[:, 0])[::-1]
        axes = particles[sorted_indices[:n]]
        
        # Calculer œÑ_N
        pt_total = np.sum(particles[:, 0])
        tau_n = 0.0
        
        for p in particles:
            # Distance √† l'axe le plus proche
            min_dist = float('inf')
            for axis in axes:
                deta = p[1] - axis[1]
                dphi = self._delta_phi(p[2], axis[2])
                dr = np.sqrt(deta**2 + dphi**2)
                min_dist = min(min_dist, dr)
            
            tau_n += p[0] * (min_dist ** beta)
        
        tau_n /= pt_total if pt_total > 0 else 1.0
        
        return tau_n
    
    def compute_multiplicity(self, particles: np.ndarray,
                            charged_only: bool = False) -> Dict:
        """
        Multiplicit√© de constituants
        """
        n_total = len(particles)
        
        # Multiplicit√© charg√©e (approximation: particules avec pT > seuil)
        charged = particles[particles[:, 0] > 1.0]  # pT > 1 GeV
        n_charged = len(charged)
        
        # Fraction neutre
        neutral_fraction = 1.0 - (n_charged / n_total) if n_total > 0 else 0.0
        
        return {
            'total_multiplicity': n_total,
            'charged_multiplicity': n_charged,
            'neutral_fraction': neutral_fraction
        }
    
    def compute_all_features(self, particles: np.ndarray) -> np.ndarray:
        """
        Calcule toutes les features pour un jet
        """
        features = []
        
        # Cin√©matique
        kin = self.compute_kinematic_features(particles, particles)
        jet_axis = np.array([kin['eta'], kin['phi']])
        
        features.extend([kin['pt'], kin['eta'], kin['mass'], kin['energy']])
        
        # Forme
        shape = self.compute_shape_features(particles, jet_axis)
        features.extend([shape['width'], shape['pt_D']])
        
        # N-subjettiness
        for n in [1, 2, 3]:
            tau_n = self.compute_nsubjettiness(particles, n=n)
            features.append(tau_n)
        
        # Multiplicit√©
        mult = self.compute_multiplicity(particles)
        features.extend([mult['total_multiplicity'], 
                        mult['charged_multiplicity'],
                        mult['neutral_fraction']])
        
        return np.array(features)
    
    def _delta_phi(self, phi1: float, phi2: float) -> float:
        """Calcule ŒîœÜ"""
        dphi = phi1 - phi2
        while dphi > np.pi:
            dphi -= 2 * np.pi
        while dphi < -np.pi:
            dphi += 2 * np.pi
        return abs(dphi)
    
    def _compute_invariant_mass(self, particles: np.ndarray) -> float:
        """Calcule masse invariante"""
        px = np.sum(particles[:, 0] * np.cos(particles[:, 2]))
        py = np.sum(particles[:, 0] * np.sin(particles[:, 2]))
        pz = np.sum(particles[:, 0] * np.sinh(particles[:, 1]))
        E = np.sum(particles[:, 3])
        
        p = np.sqrt(px**2 + py**2 + pz**2)
        mass = np.sqrt(max(0, E**2 - p**2))
        return mass

# Calculer features
jet_features = JetFeatures()
features = jet_features.compute_all_features(particles[:10])  # Premier jet

print(f"\nFeatures de Jet ({len(features)} features):")
print(f"  Cin√©matique: pt, eta, mass, energy")
print(f"  Forme: width, pt_D")
print(f"  N-subjettiness: œÑ1, œÑ2, œÑ3")
print(f"  Multiplicit√©: total, charged, neutral_fraction")
```

---

## Classification de Jets avec ML

### Mod√®les de Classification

```python
class JetClassifier(nn.Module):
    """
    Classificateur de jets (quark vs gluon, etc.)
    """
    
    def __init__(self, n_features=16, n_classes=2, hidden_dim=128):
        """
        Args:
            n_features: Nombre de features input
            n_classes: Nombre de classes (ex: 2 pour quark/gluon)
        """
        super().__init__()
        
        self.classifier = nn.Sequential(
            nn.Linear(n_features, hidden_dim),
            nn.BatchNorm1d(hidden_dim),
            nn.ReLU(),
            nn.Dropout(0.3),
            
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.BatchNorm1d(hidden_dim // 2),
            nn.ReLU(),
            nn.Dropout(0.2),
            
            nn.Linear(hidden_dim // 2, hidden_dim // 4),
            nn.ReLU(),
            nn.Dropout(0.1),
            
            nn.Linear(hidden_dim // 4, n_classes)
        )
    
    def forward(self, jet_features):
        """
        Args:
            jet_features: (batch, n_features)
        """
        return self.classifier(jet_features)

class JetImageCNN(nn.Module):
    """
    CNN pour classification depuis images de jets (Œ∑-œÜ)
    """
    
    def __init__(self, n_classes=2):
        """
        Traite jet comme image 2D (Œ∑ √ó œÜ)
        """
        super().__init__()
        
        self.conv_layers = nn.Sequential(
            # Conv Block 1
            nn.Conv2d(1, 32, kernel_size=3, padding=1),
            nn.BatchNorm2d(32),
            nn.ReLU(),
            nn.MaxPool2d(2),
            
            # Conv Block 2
            nn.Conv2d(32, 64, kernel_size=3, padding=1),
            nn.BatchNorm2d(64),
            nn.ReLU(),
            nn.MaxPool2d(2),
            
            # Conv Block 3
            nn.Conv2d(64, 128, kernel_size=3, padding=1),
            nn.BatchNorm2d(128),
            nn.ReLU(),
            nn.MaxPool2d(2),
        )
        
        # Classifier
        self.classifier = nn.Sequential(
            nn.Flatten(),
            nn.Linear(128 * 4 * 4, 256),  # Ajuster selon taille image
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(256, n_classes)
        )
    
    def forward(self, jet_image):
        """
        Args:
            jet_image: (batch, 1, height, width) image du jet
        """
        features = self.conv_layers(jet_image)
        return self.classifier(features)
    
    def create_jet_image(self, particles: np.ndarray, 
                        image_size: Tuple[int, int] = (32, 32),
                        eta_range: Tuple[float, float] = (-2, 2),
                        phi_range: Tuple[float, float] = (-np.pi, np.pi)) -> np.ndarray:
        """
        Cr√©e image du jet depuis particules
        
        Image = carte de densit√© pT en (Œ∑, œÜ)
        """
        image = np.zeros(image_size)
        
        eta_bins = np.linspace(eta_range[0], eta_range[1], image_size[0] + 1)
        phi_bins = np.linspace(phi_range[0], phi_range[1], image_size[1] + 1)
        
        for p in particles:
            pt, eta, phi = p[0], p[1], p[2]
            
            # Trouver bin
            eta_idx = np.digitize(eta, eta_bins) - 1
            phi_idx = np.digitize(phi, phi_bins) - 1
            
            if 0 <= eta_idx < image_size[0] and 0 <= phi_idx < image_size[1]:
                image[eta_idx, phi_idx] += pt
        
        return image

# Cr√©er mod√®les
feature_classifier = JetClassifier(n_features=14, n_classes=2)
image_classifier = JetImageCNN(n_classes=2)

print(f"\nMod√®les de Classification:")
print(f"  Feature-based: {sum(p.numel() for p in feature_classifier.parameters()):,} param√®tres")
print(f"  Image-based: {sum(p.numel() for p in image_classifier.parameters()):,} param√®tres")
```

---

## Quark vs Gluon Classification

### Classification Sp√©cifique

```python
class QuarkGluonClassifier(nn.Module):
    """
    Classification quark vs gluon
    
    Diff√©rences:
    - Gluons: plus de particules, plus large
    - Quarks: plus compact, moins de particules
    """
    
    def __init__(self):
        super().__init__()
        
        # Features importantes pour quark/gluon
        self.classifier = nn.Sequential(
            nn.Linear(16, 128),
            nn.BatchNorm1d(128),
            nn.ReLU(),
            nn.Dropout(0.3),
            
            nn.Linear(128, 64),
            nn.BatchNorm1d(64),
            nn.ReLU(),
            nn.Dropout(0.2),
            
            nn.Linear(64, 1),
            nn.Sigmoid()  # Probabilit√© quark
        )
    
    def forward(self, features):
        """
        Args:
            features: Features du jet
                [pt, eta, mass, width, pt_D, œÑ1, œÑ2, œÑ3, 
                 multiplicity, charged_mult, ...]
        """
        return self.classifier(features)
    
    def get_quark_probability(self, jet_features):
        """Retourne probabilit√© que jet soit quark"""
        with torch.no_grad():
            prob = self.forward(jet_features)
            return prob.item()

# Simuler donn√©es quark/gluon
def simulate_quark_jet():
    """Simule jet de quark (plus compact)"""
    n_particles = np.random.poisson(10)  # Moins de particules
    particles = np.random.rand(n_particles, 4)
    particles[:, 0] *= 30  # pT
    particles[:, 1] = np.random.normal(0, 0.3, n_particles)  # Plus compact
    particles[:, 2] = np.random.normal(0, 0.3, n_particles)
    particles[:, 3] = particles[:, 0] * np.cosh(particles[:, 1])
    return particles

def simulate_gluon_jet():
    """Simule jet de gluon (plus large)"""
    n_particles = np.random.poisson(20)  # Plus de particules
    particles = np.random.rand(n_particles, 4)
    particles[:, 0] *= 30  # pT
    particles[:, 1] = np.random.normal(0, 0.6, n_particles)  # Plus large
    particles[:, 2] = np.random.normal(0, 0.6, n_particles)
    particles[:, 3] = particles[:, 0] * np.cosh(particles[:, 1])
    return particles

# Cr√©er classificateur
qg_classifier = QuarkGluonClassifier()

# Test
quark_jet = simulate_quark_jet()
gluon_jet = simulate_gluon_jet()

quark_features = torch.tensor(jet_features.compute_all_features(quark_jet), dtype=torch.float32).unsqueeze(0)
gluon_features = torch.tensor(jet_features.compute_all_features(gluon_jet), dtype=torch.float32).unsqueeze(0)

quark_prob = qg_classifier.get_quark_probability(quark_features)
gluon_prob = qg_classifier.get_quark_probability(gluon_features)

print(f"\nClassification Quark vs Gluon:")
print(f"  Quark jet prob: {quark_prob:.3f} (devrait √™tre proche de 1)")
print(f"  Gluon jet prob: {gluon_prob:.3f} (devrait √™tre proche de 0)")
```

---

## Exercices

### Exercice 19.2.1
Impl√©mentez l'algorithme de clustering anti-kT complet avec gestion correcte de la combinaison de particules.

### Exercice 19.2.2
Cr√©ez un syst√®me de classification de jets qui combine features classiques et CNN sur images de jets.

### Exercice 19.2.3
Entra√Ænez un classificateur quark/gluon et analysez quelles features sont les plus importantes.

### Exercice 19.2.4
D√©veloppez un syst√®me qui classe simultan√©ment le type de jet (quark/gluon) et la saveur (u, d, s, c, b).

---

## Points Cl√©s √† Retenir

> üìå **Les algorithmes de clustering (anti-kT) groupent particules en jets**

> üìå **Les features de forme (width, N-subjettiness) distinguent diff√©rents types de jets**

> üìå **Les mod√®les ML peuvent utiliser features ou images directement**

> üìå **La classification quark/gluon est importante pour r√©duire background**

> üìå **Les CNNs sur images de jets exploitent structure spatiale du d√©tecteur**

> üìå **La multiplicit√© et la largeur sont des discriminants cl√©s**

---

*Section pr√©c√©dente : [19.1 Reconstruction de Traces](./19_01_Traces.md) | Section suivante : [19.3 Tagging de Saveurs](./19_03_Tagging.md)*

