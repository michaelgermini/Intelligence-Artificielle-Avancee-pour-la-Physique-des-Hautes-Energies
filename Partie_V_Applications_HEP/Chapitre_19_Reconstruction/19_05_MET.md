# 19.5 Reconstruction de l'√ânergie Manquante

---

## Introduction

L'**√©nergie manquante transverse (MET - Missing Transverse Energy)** est une quantit√© fondamentale en physique des hautes √©nergies. Elle correspond √† l'√©nergie des particules non d√©tect√©es (neutrinos, particules de mati√®re noire) et est cruciale pour identifier des processus comme la production de bosons W (qui se d√©sint√®grent en lepton + neutrino) ou la recherche de mati√®re noire.

Cette section pr√©sente les m√©thodes de reconstruction du MET, les corrections appliqu√©es, et l'utilisation du machine learning pour am√©liorer la r√©solution.

---

## D√©finition du MET

### Calcul de Base

```python
import numpy as np
import torch
import torch.nn as nn
from typing import List, Dict, Tuple

class METBasics:
    """
    Bases de la reconstruction MET
    """
    
    def __init__(self):
        self.definition = """
        Missing Transverse Energy (MET):
        
        MET_x = -Œ£_i pT_i * cos(œÜ_i)
        MET_y = -Œ£_i pT_i * sin(œÜ_i)
        
        o√π la somme porte sur toutes les particules d√©tect√©es.
        
        MET = ‚àö(MET_x¬≤ + MET_y¬≤)
        MET_œÜ = arctan(MET_y / MET_x)
        
        Signification physique:
        - Neutrinos (non d√©tect√©s) contribuent au MET
        - Particules non reconstruites cr√©ent MET faux
        - R√©solution limit√©e par r√©solution √©nerg√©tique des d√©tecteurs
        """
    
    def compute_basic_met(self, particles: np.ndarray) -> Dict:
        """
        Calcule MET basique depuis particules
        
        Args:
            particles: (n_particles, 4) [pT, Œ∑, œÜ, E]
        """
        # Composantes x et y
        met_x = -np.sum(particles[:, 0] * np.cos(particles[:, 2]))
        met_y = -np.sum(particles[:, 0] * np.sin(particles[:, 2]))
        
        # Magnitude et angle
        met_magnitude = np.sqrt(met_x**2 + met_y**2)
        met_phi = np.arctan2(met_y, met_x)
        
        return {
            'met': met_magnitude,
            'met_x': met_x,
            'met_y': met_y,
            'met_phi': met_phi
        }
    
    def display_definition(self):
        """Affiche la d√©finition"""
        print("\n" + "="*70)
        print("Missing Transverse Energy (MET)")
        print("="*70)
        print(self.definition)

basics = METBasics()
basics.display_definition()

# Exemple calcul basique
particles = np.random.rand(100, 4)
particles[:, 0] *= 50  # pT en GeV
particles[:, 2] = np.random.uniform(-np.pi, np.pi, 100)  # œÜ

met_result = basics.compute_basic_met(particles)
print(f"\nMET basique:")
print(f"  MET: {met_result['met']:.2f} GeV")
print(f"  MET_œÜ: {met_result['met_phi']:.3f} rad")
```

---

## Sources de MET

### Composantes

```python
class METComponents:
    """
    Composantes du MET
    """
    
    def __init__(self):
        self.components = {
            'calorimeter_met': {
                'description': 'MET depuis calorim√®tres (ECAL + HCAL)',
                'resolution': '~10-15% pour MET > 100 GeV',
                'advantages': 'Couverture compl√®te en Œ∑',
                'disadvantages': 'R√©solution limit√©e, non-lin√©arit√©'
            },
            'track_met': {
                'description': 'MET depuis traces charg√©es seulement',
                'resolution': 'Meilleure r√©solution angulaire',
                'advantages': 'R√©solution excellente, rapide',
                'disadvantages': 'Couverture limit√©e (|Œ∑| < 2.5), manque neutres'
            },
            'pf_met': {
                'description': 'Particle Flow MET (recommand√© au LHC)',
                'resolution': 'Meilleure combinaison',
                'advantages': 'Combine toutes les informations',
                'disadvantages': 'Plus complexe'
            }
        }
    
    def compute_particle_flow_met(self, 
                                 charged_particles: np.ndarray,
                                 neutral_particles: np.ndarray,
                                 muons: np.ndarray) -> Dict:
        """
        Calcule MET avec m√©thode Particle Flow
        
        Combine toutes les sources d'information
        """
        # MET depuis particules charg√©es (tracker)
        met_charged_x = -np.sum(charged_particles[:, 0] * np.cos(charged_particles[:, 2]))
        met_charged_y = -np.sum(charged_particles[:, 0] * np.sin(charged_particles[:, 2]))
        
        # MET depuis particules neutres (calorim√®tres)
        met_neutral_x = -np.sum(neutral_particles[:, 0] * np.cos(neutral_particles[:, 2]))
        met_neutral_y = -np.sum(neutral_particles[:, 0] * np.sin(neutral_particles[:, 2]))
        
        # MET depuis muons (d√©tecteur muon)
        met_muon_x = -np.sum(muons[:, 0] * np.cos(muons[:, 2])) if len(muons) > 0 else 0
        met_muon_y = -np.sum(muons[:, 0] * np.sin(muons[:, 2])) if len(muons) > 0 else 0
        
        # Combinaison
        met_x = met_charged_x + met_neutral_x + met_muon_x
        met_y = met_charged_y + met_neutral_y + met_muon_y
        
        met = np.sqrt(met_x**2 + met_y**2)
        met_phi = np.arctan2(met_y, met_x)
        
        return {
            'met': met,
            'met_x': met_x,
            'met_y': met_y,
            'met_phi': met_phi,
            'components': {
                'charged': np.sqrt(met_charged_x**2 + met_charged_y**2),
                'neutral': np.sqrt(met_neutral_x**2 + met_neutral_y**2),
                'muon': np.sqrt(met_muon_x**2 + met_muon_y**2)
            }
        }

met_components = METComponents()

# Simuler donn√©es
charged = np.random.rand(50, 4)
charged[:, 0] *= 30
charged[:, 2] = np.random.uniform(-np.pi, np.pi, 50)

neutral = np.random.rand(30, 4)
neutral[:, 0] *= 20
neutral[:, 2] = np.random.uniform(-np.pi, np.pi, 30)

muons = np.random.rand(5, 4)
muons[:, 0] *= 25
muons[:, 2] = np.random.uniform(-np.pi, np.pi, 5)

pf_met = met_components.compute_particle_flow_met(charged, neutral, muons)

print(f"\nParticle Flow MET:")
print(f"  MET total: {pf_met['met']:.2f} GeV")
print(f"  Composante charg√©e: {pf_met['components']['charged']:.2f} GeV")
print(f"  Composante neutre: {pf_met['components']['neutral']:.2f} GeV")
print(f"  Composante muon: {pf_met['components']['muon']:.2f} GeV")
```

---

## Corrections du MET

### Corrections Syst√©matiques

```python
class METCorrections:
    """
    Corrections appliqu√©es au MET
    """
    
    def apply_jet_corrections(self, met_x: float, met_y: float,
                             jets: List[Dict]) -> Tuple[float, float]:
        """
        Corrections pour jets (JEC - Jet Energy Corrections)
        
        Les jets mal calibr√©s affectent le MET
        """
        corrected_met_x = met_x
        corrected_met_y = met_y
        
        for jet in jets:
            # Correction d'√©nergie du jet
            raw_pt = jet.get('raw_pt', jet['pt'])
            corrected_pt = raw_pt * jet.get('jec_factor', 1.0)
            
            # Diff√©rence
            delta_pt = corrected_pt - raw_pt
            delta_met_x = -delta_pt * np.cos(jet['phi'])
            delta_met_y = -delta_pt * np.sin(jet['phi'])
            
            corrected_met_x += delta_met_x
            corrected_met_y += delta_met_y
        
        return corrected_met_x, corrected_met_y
    
    def apply_muon_corrections(self, met_x: float, met_y: float,
                              muons: List[Dict]) -> Tuple[float, float]:
        """
        Corrections pour muons
        
        Muons d√©posent peu dans calorim√®tres, doivent √™tre trait√©s sp√©cialement
        """
        corrected_met_x = met_x
        corrected_met_y = met_y
        
        for muon in muons:
            # Soustraire d√©p√¥t calorim√©trique du muon
            calo_deposit = muon.get('calo_energy', 0)
            if calo_deposit > 0:
                # Ajouter cette √©nergie au MET (elle √©tait compt√©e mais ne devrait pas)
                corrected_met_x += calo_deposit * np.cos(muon['phi'])
                corrected_met_y += calo_deposit * np.sin(muon['phi'])
        
        return corrected_met_x, corrected_met_y
    
    def apply_unclustered_energy_correction(self, met_x: float, met_y: float,
                                           unclustered_energy: float) -> Tuple[float, float]:
        """
        Correction pour √©nergie non clusteris√©e
        
        √ânergie dans calorim√®tres non associ√©e √† objets reconstruits
        """
        # Simplifi√©: assume distribution uniforme
        # En pratique: utiliser direction de l'√©nergie non clusteris√©e
        
        return met_x, met_y
    
    def apply_all_corrections(self, met_x: float, met_y: float,
                             jets: List[Dict],
                             muons: List[Dict],
                             unclustered_energy: float = 0) -> Dict:
        """
        Applique toutes les corrections
        """
        # Corrections en s√©quence
        corr_x, corr_y = self.apply_jet_corrections(met_x, met_y, jets)
        corr_x, corr_y = self.apply_muon_corrections(corr_x, corr_y, muons)
        corr_x, corr_y = self.apply_unclustered_energy_correction(
            corr_x, corr_y, unclustered_energy
        )
        
        met_before = np.sqrt(met_x**2 + met_y**2)
        met_after = np.sqrt(corr_x**2 + corr_y**2)
        
        return {
            'met_x_corrected': corr_x,
            'met_y_corrected': corr_y,
            'met_corrected': met_after,
            'met_phi_corrected': np.arctan2(corr_y, corr_x),
            'met_before': met_before,
            'correction_delta': met_after - met_before
        }

# Appliquer corrections
corrections = METCorrections()

met_x, met_y = 50.0, 30.0
jets = [
    {'pt': 100, 'phi': 0.5, 'raw_pt': 95, 'jec_factor': 1.05},
    {'pt': 80, 'phi': 1.2, 'raw_pt': 78, 'jec_factor': 1.03}
]
muons = [
    {'phi': 0.3, 'calo_energy': 2.0}
]

corrected = corrections.apply_all_corrections(met_x, met_y, jets, muons)

print(f"\nCorrections MET:")
print(f"  MET avant: {corrected['met_before']:.2f} GeV")
print(f"  MET apr√®s: {corrected['met_corrected']:.2f} GeV")
print(f"  Delta: {corrected['correction_delta']:.2f} GeV")
```

---

## R√©solution du MET

### Estimation d'Incertitude

```python
class METResolution:
    """
    Estimation de la r√©solution du MET
    """
    
    def compute_met_uncertainty(self, particles: np.ndarray,
                               resolution_per_particle: float = 0.1) -> Dict:
        """
        Estime incertitude sur MET
        
        R√©solution typique: ~10% par GeV de MET
        """
        # Incertitude en quadrature
        uncertainty_x_sq = 0
        uncertainty_y_sq = 0
        
        for p in particles:
            pt, phi = p[0], p[2]
            
            # Incertitude sur pT
            sigma_pt = pt * resolution_per_particle
            
            # Contribution √† MET_x et MET_y
            sigma_x = sigma_pt * abs(np.cos(phi))
            sigma_y = sigma_pt * abs(np.sin(phi))
            
            uncertainty_x_sq += sigma_x**2
            uncertainty_y_sq += sigma_y**2
        
        # Incertitude totale (propagation d'erreur)
        met = np.sqrt(np.sum(particles[:, 0] * np.cos(particles[:, 2]))**2 +
                     np.sum(particles[:, 0] * np.sin(particles[:, 2]))**2)
        
        # Approximation: incertitude = ‚àö(œÉ_x¬≤ + œÉ_y¬≤)
        uncertainty = np.sqrt(uncertainty_x_sq + uncertainty_y_sq)
        
        # R√©solution relative
        resolution = uncertainty / met if met > 0 else 0
        
        return {
            'met': met,
            'uncertainty': uncertainty,
            'uncertainty_x': np.sqrt(uncertainty_x_sq),
            'uncertainty_y': np.sqrt(uncertainty_y_sq),
            'relative_resolution': resolution
        }
    
    def compute_met_significance(self, met: float, 
                                met_uncertainty: float) -> float:
        """
        Calcule significativit√© du MET
        
        MET_significance = MET / œÉ_MET
        """
        significance = met / met_uncertainty if met_uncertainty > 0 else 0
        return significance

resolution = METResolution()

uncertainty = resolution.compute_met_uncertainty(particles, resolution_per_particle=0.15)
significance = resolution.compute_met_significance(uncertainty['met'], uncertainty['uncertainty'])

print(f"\nR√©solution MET:")
print(f"  MET: {uncertainty['met']:.2f} GeV")
print(f"  Incertitude: {uncertainty['uncertainty']:.2f} GeV")
print(f"  R√©solution relative: {uncertainty['relative_resolution']:.2%}")
print(f"  Significativit√©: {significance:.2f}")
```

---

## ML pour Am√©lioration du MET

### Mod√®les de Pr√©diction

```python
class METMLCorrection(nn.Module):
    """
    Mod√®le ML pour correction et am√©lioration du MET
    """
    
    def __init__(self, n_features=20):
        """
        Features: propri√©t√©s de l'√©v√©nement, jets, leptons, etc.
        """
        super().__init__()
        
        # Pr√©dit correction au MET
        self.corrector = nn.Sequential(
            nn.Linear(n_features, 128),
            nn.ReLU(),
            nn.Dropout(0.2),
            
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Dropout(0.1),
            
            nn.Linear(64, 2)  # [ŒîMET_x, ŒîMET_y]
        )
        
        # Pr√©dit incertitude
        self.uncertainty_estimator = nn.Sequential(
            nn.Linear(n_features, 64),
            nn.ReLU(),
            nn.Linear(64, 1),
            nn.ReLU()  # Incertitude > 0
        )
    
    def forward(self, event_features):
        """
        Returns:
            correction: (batch, 2) [ŒîMET_x, ŒîMET_y]
            uncertainty: (batch, 1) œÉ_MET
        """
        correction = self.corrector(event_features)
        uncertainty = self.uncertainty_estimator(event_features)
        
        return correction, uncertainty
    
    def correct_met(self, met_x: float, met_y: float, event_features: torch.Tensor):
        """
        Applique correction ML au MET
        """
        with torch.no_grad():
            correction, uncertainty = self.forward(event_features)
            
            corrected_x = met_x + correction[0, 0].item()
            corrected_y = met_y + correction[0, 1].item()
            
            return {
                'met_x_corrected': corrected_x,
                'met_y_corrected': corrected_y,
                'met_corrected': np.sqrt(corrected_x**2 + corrected_y**2),
                'uncertainty': uncertainty[0, 0].item()
            }

class METEventFeatures:
    """
    Extraction de features d'√©v√©nement pour correction MET
    """
    
    def extract_features(self, jets: List[Dict],
                        leptons: List[Dict],
                        met_raw: Dict) -> np.ndarray:
        """
        Extrait features pertinentes pour correction MET
        """
        features = []
        
        # Features MET brut
        features.extend([met_raw['met'], met_raw['met_phi']])
        
        # Features jets
        if len(jets) > 0:
            jet_pts = [j['pt'] for j in jets]
            features.extend([
                len(jets),
                np.sum(jet_pts),
                np.max(jet_pts) if jet_pts else 0,
                np.mean(jet_pts) if jet_pts else 0
            ])
        else:
            features.extend([0, 0, 0, 0])
        
        # Features leptons
        if len(leptons) > 0:
            lepton_pts = [l['pt'] for l in leptons]
            features.extend([
                len(leptons),
                np.sum(lepton_pts),
                np.max(lepton_pts) if lepton_pts else 0
            ])
        else:
            features.extend([0, 0, 0])
        
        # Autres features
        features.extend([
            len(jets) + len(leptons),  # Total objets
            met_raw['met'] / (np.sum(jet_pts) if jets else 1)  # Ratio MET/HT
        ])
        
        return np.array(features)

# Cr√©er mod√®le
met_ml = METMLCorrection(n_features=14)

# Extraire features
feature_extractor = METEventFeatures()
event_features = feature_extractor.extract_features(
    jets=[{'pt': 100}, {'pt': 80}],
    leptons=[{'pt': 30}],
    met_raw={'met': 50, 'met_phi': 0.5}
)

features_tensor = torch.tensor(event_features, dtype=torch.float32).unsqueeze(0)
corrected = met_ml.correct_met(45.0, 25.0, features_tensor)

print(f"\nCorrection ML MET:")
print(f"  MET avant: 50.0 GeV")
print(f"  MET apr√®s: {corrected['met_corrected']:.2f} GeV")
print(f"  Incertitude estim√©e: {corrected['uncertainty']:.2f} GeV")
```

---

## Exercices

### Exercice 19.5.1
Impl√©mentez un calculateur de MET avec corrections compl√®tes (jets, muons, √©nergie non clusteris√©e).

### Exercice 19.5.2
D√©veloppez un mod√®le ML qui pr√©dit la correction du MET depuis les propri√©t√©s de l'√©v√©nement.

### Exercice 19.5.3
Analysez l'impact de la r√©solution √©nerg√©tique des calorim√®tres sur la r√©solution du MET.

### Exercice 19.5.4
Cr√©ez un syst√®me qui estime l'incertitude sur le MET et calcule la significativit√©.

---

## Points Cl√©s √† Retenir

> üìå **Le MET est calcul√© comme oppos√© de la somme vectorielle des pT**

> üìå **Le Particle Flow MET combine informations tracker + calorim√®tres + muons**

> üìå **Les corrections (jets, muons, √©nergie non clusteris√©e) sont essentielles**

> üìå **La r√©solution du MET est typiquement ~10-15% pour MET > 100 GeV**

> üìå **Le ML peut am√©liorer la r√©solution en apprenant des patterns complexes**

> üìå **La significativit√© du MET permet de distinguer MET vrai du bruit**

---

*Section pr√©c√©dente : [19.4 Identification de Leptons](./19_04_Leptons.md)*

